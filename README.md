# Программное средство для администрирования распределенных информационных киосков организации

Описание проекта: Проект представляет собой программное средство для администрирования распределённых информационных киосков организации. Система предназначена для централизованного управления сетью киосков, которые предоставляют пользователям доступ к различным информационным и интерактивным сервисам. Основной задачей проекта является упрощение процесса администрирования, мониторинга и обновления контента на всех устройствах, что обеспечивает их стабильную работу и актуальность предоставляемой информации.

Цели проекта: Главная цель проекта — повышение эффективности управления распределёнными информационными киосками. Система позволит сократить время и ресурсы, затрачиваемые на обслуживание оборудования, упростить процесс обновления программного обеспечения и контента, а также обеспечить высокий уровень контроля за работой киосков в режиме реального времени.

Основные возможности: Программное средство предоставляет централизованное управление сетью киосков, позволяя администраторам контролировать их состояние, обновлять программное обеспечение и контент, управлять пользователями и их правами доступа. Система формирует аналитические отчёты и статистику работы киосков, что способствует оптимизации их использования. Кроме того, она обеспечивает автоматическую отправку уведомлений о неисправностях и сбоях, что позволяет быстро реагировать на проблемы. Решение отличается высокой надёжностью, безопасностью данных и возможностью масштабирования при увеличении количества устройств.

**Front:** [GitHub репозиторий](https://github.com/lizgorovaya/ADMFront)  
**Back:** [GitHub репозиторий](https://github.com/lizgorovaya/admin-panel)


## Содержание

1. [Архитектура](#архитектура)  
   i. [C4-модель](#c4-модель)  
   ii. [Схема данных](#схема-данных)  

2. [Функциональные возможности](#функциональные-возможности)  
   i. [Диаграмма вариантов использования](#диаграмма-вариантов-использования)  
   ii. [User-flow диаграммы](#user-flow-диаграммы)  

3. [Детали реализации](#детали-реализации)  
   i. [UML-диаграммы](#uml-диаграммы)  
   ii. [Спецификация API](#спецификация-api)  
   iii. [Безопасность](#безопасность)  
   iv. [Оценка качества кода](#оценка-качества-кода)  

4. [Тестирование](#тестирование)  
   i. [Unit-тесты](#unit-тесты)  
   ii. [Интеграционные тесты](#интеграционные-тесты)  

5. [Установка и запуск](#установка-и-запуск)  
   i. [Манифесты для сборки docker образов](#манифесты-для-сборки-docker-образов)  
   ii. [Манифесты для развертывания k8s кластера](#манифесты-для-развертывания-k8s-кластера)  

6. [Лицензия](#лицензия)  
7. [Контакты](#контакты)




## Архитектура

### C4-модель


Модель C4 важна при построении архитектуры программных систем, так как она позволяет наглядно и поэтапно описывать структуру проекта на разных уровнях абстракции. С её помощью можно показать, как система взаимодействует с внешними пользователями и другими системами, из каких контейнеров (приложений, сервисов, баз данных) она состоит, как устроены её внутренние компоненты и каким образом реализован код. На рисунке 1 представлена модель контейнерного уровня С4.

<img width="975" height="631" alt="image" src="https://github.com/user-attachments/assets/6cefd2be-f334-46b0-89e5-44ad8f36fdf5" />

Диаграмма описывает систему взаимодействия пользователей с программным средством администрирования инфокиосков, предназначенную для централизованного управления контентом, пользователями и аналитикой. Администратор Брестэнерго управляет системой и пользователями, контролирует работу контент-менеджеров и аналитиков, а также следит за состоянием инфокиосков через веб-сервис администрирования. Контент-менеджер редактирует и обновляет материалы, которые отображаются на инфокиосках, загружает новые данные и корректирует существующий контент. Аналитик просматривает отчёты и статистику использования инфокиосков, получая информацию о посещаемости, активности пользователей и эффективности контента через программное средство.    
Программное средство администрирования является центральным элементом системы, обеспечивая взаимодействие всех пользователей и получая контент от внешних систем, представленных тремя экземплярами инфокиосков. Пользователи работают с веб-сервисом, который, в свою очередь, интегрирован с инфокиосками для актуализации контента, а администратор обеспечивает корректную работу системы и управление ролями. Таким образом, система обеспечивает централизованное управление контентом, контроль доступа и ролей пользователей, получение и отображение аналитических данных и взаимодействие с внешними инфокиосками для поддержания актуальности информации.
Далее представлена компонентный уровень модели С4 для детального представления программного обеспечения внутри одного контейнера. Она показывает, как система организована из отдельных компонентов, какие у них обязанности, как они взаимодействуют друг с другом и с внешними системами. На рисунке 2 представлена модель компонентного уровня модели С4.

<img width="974" height="494" alt="image" src="https://github.com/user-attachments/assets/f055a10b-52f4-4876-843f-028092d4db88" />

В системе выделяется три типа пользователей. Администратор управляет системой и пользователями, назначает роли, контролирует корректность работы контент-менеджеров и аналитиков, а также мониторит работу инфокиосков. Контент-менеджер отвечает за подготовку и публикацию материалов: он редактирует текст, изображения и другие элементы контента, который затем отображается на инфокиосках. Аналитик получает доступ к отчётам и статистике, формируемой системой, что позволяет оценивать эффективность публикаций и активность пользователей. Все пользователи взаимодействуют с системой через веб-приложение, которое служит интерфейсом для выполнения всех задач: управления пользователями, публикации контента и просмотра аналитики.
Веб-приложение представляет собой фронтенд, построенный как клиентское веб-приложение, которое делает запросы к API-сервису. Оно обеспечивает удобный интерфейс и визуализацию данных для всех типов пользователей, управляет навигацией, формами редактирования и представлением отчётов.
API-сервис является центральным компонентом backend. Он обрабатывает запросы веб-приложения, управляет пользователями и ролями, хранит и обновляет контент, собирает и обрабатывает журналы посещений от инфокиосков. Кроме того, API-сервис реализует бизнес-логику и маршрутизацию данных между компонентами системы, обеспечивая целостность и согласованность информации.
База данных MySQL хранит всю основную информацию: сведения о пользователях, их ролях, опубликованном контенте и журналы посещений инфокиосков. Она служит основным источником данных для API-сервиса и модуля аналитики.
Инфокиоски подключаются к системе через API-сервис. Они получают актуальный контент для отображения и передают обратно журналы посещений и другую статистическую информацию. Это позволяет системе поддерживать контент в актуальном состоянии и собирать данные для анализа.
Модуль аналитики, встроенный в backend, обрабатывает журналы посещений, анализирует активность пользователей и эффективность контента, а затем формирует отчёты, доступные аналитикам через веб-приложение. Модуль позволяет оценивать работу инфокиосков, выявлять популярный контент и принимать управленческие решения.
Таким образом, система реализует полный цикл администрирования и анализа: пользователи через веб-приложение управляют контентом и ролями, API-сервис обеспечивает обработку данных и взаимодействие с базой, инфокиоски получают контент и передают статистику, а модуль аналитики формирует отчёты для оценки эффективности работы системы.

### Схема данных

<img width="974" height="480" alt="image" src="https://github.com/user-attachments/assets/0a2f34a2-251c-4c45-b1be-1e8f36a1da4f" />


Проектируемая база данных kiosk_admin соответствует требованиям третьей нормальной формы (3НФ), так как все таблицы содержат атрибуты, функционально зависящие только от своих первичных ключей, и не имеют транзитивных зависимостей между неключевыми полями. 
Таблица users. Таблица хранит информацию о пользователях системы. Каждый атрибут (username, password_hash, role, created_at) однозначно зависит от первичного ключа id. Между неключевыми атрибутами функциональных зависимостей нет – роль пользователя не зависит от его имени или даты создания записи. Следовательно, таблица users находится в 3НФ.
Таблица kiosks. Таблица содержит сведения о киосках, подключённых к системе. Все поля (name, location, ip_address, status, last_sync) зависят исключительно от ключа id. Поле status не зависит ни от имени, ни от IP-адреса, что исключает транзитивные зависимости. Таким образом, таблица kiosks удовлетворяет требованиям 3НФ.
Таблица content_types Таблица описывает типы контента (текст, изображение, видео). Атрибут name функционально зависит только от id, и так как других неключевых атрибутов нет, таблица полностью нормализована. content_types находится в 3НФ.
Таблица contents. Таблица хранит контент, размещаемый на киосках. Атрибуты (title, type_id, data_url, created_by, created_at, updated_at) полностью зависят от первичного ключа id. Поля type_id и created_by являются внешними ключами, которые обеспечивают связь с таблицами content_types и users, исключая дублирование данных. Зависимостей между неключевыми полями нет. Таблица находится в 3НФ.
Таблица deployments описывает размещение контента на киосках. Каждый атрибут (kiosk_id, content_id, deployed_at, status) зависит только от идентификатора развертывания id. Внешние ключи kiosk_id и content_id корректно связывают таблицу с киосками и контентом, обеспечивая целостность данных. Никаких транзитивных зависимостей между полями нет, следовательно, таблица соответствует 3НФ.
Таблица logs предназначена для хранения журналов событий, связанных с киосками. Поля (kiosk_id, level, message, created_at) функционально зависят от первичного ключа id. Поле kiosk_id является внешним ключом, связывающим запись лога с конкретным киоском. В таблице отсутствуют зависимости между неключевыми атрибутами, поэтому она также находится в 3НФ.


## Функциональные возможности

### Диаграмма вариантов использования

### User-flow диаграммы

Первый разработанный user-flow для роли – системный администратор.
Цель роли системный администратор обеспечивает безопасное и стабильное функционирование всей системы администрирования киосков. Он управляет правами доступа пользователей, контролирует действия сотрудников и следит за соблюдением политик безопасности. Роль позволяет централизованно управлять учетными записями, отслеживать все действия через журналы аудита, настраивать параметры безопасности, выполнять резервное копирование и восстановление данных. Основная цель – гарантировать, что доступ к системе имеют только уполномоченные пользователи и что вся информация надёжно защищена. Ниже описан основной путь следования системного администратора.
1 Администратор открывает страницу входа в систему и видит форму для авторизации. Он вводит логин и пароль, чтобы система могла идентифицировать его и проверить, что у него есть права администратора. Этот шаг необходим для защиты системы от несанкционированного доступа.
2 После ввода учетных данных система предлагает пройти двухфакторную аутентификацию или авторизацию через корпоративный SSO. Пользователь подтверждает свою личность с помощью кода из приложения или через корпоративный аккаунт. Это повышает безопасность и предотвращает доступ злоумышленников.
3 После успешной авторизации администратор попадает на главную панель. Здесь отображается обзор состояния системы: уведомления о действиях пользователей, последние изменения, ошибки, предупреждения, а также быстрые ссылки на основные модули.
4 Администратор выбирает модуль управления пользователями. Здесь он может создавать новых пользователей, задавать роли и права, редактировать информацию о существующих пользователях или удалять учетные записи, если они больше не нужны. Система обеспечивает контроль, чтобы изменения не повлияли на безопасность.
5 Если выбранный пользователь требует прав суперпользователя, администратор переходит в модуль настройки политик безопасности. Здесь он устанавливает ограничения доступа, проверяет полномочия и сохраняет изменения. После этого возвращается на главную панель.
6 Администратор может открыть журналы аудита, чтобы просмотреть историю действий пользователей: входы в систему, изменения данных, ошибки и подозрительные действия. При необходимости журналы можно экспортировать для анализа или отчёта.
7 Далее администратор может настроить параметры безопасности системы, включая политику паролей, ограничения доступа, двухфакторную аутентификацию и другие настройки, которые обеспечивают защиту данных.
8 При необходимости выполняется резервное копирование данных или восстановление из предыдущей копии, чтобы предотвратить потерю информации в случае сбоев или ошибок.
9 После завершения всех операций администратор выходит из системы, закрывая сеанс работы и обеспечивая безопасность системы.
Диаграмма User-flow для системного администратора представлена на рисунке 1.

<img width="974" height="767" alt="image" src="https://github.com/user-attachments/assets/fb2fd64c-c027-4bec-9075-970eae385430" />


Следующая роль, которая представлена в системе, администратор киосков. 
Цель роли: Администратор киосков отвечает за управление жизненным циклом всех устройств организации. Он добавляет новые киоски в систему, настраивает их параметры, редактирует существующие и удаляет ненужные устройства. Также он отслеживает состояние устройств, просматривает логи работы и формирует отчёты для анализа эффективности работы киосков. Основная цель роли – обеспечить корректную работу всех киосков, своевременное обновление программного обеспечения и контроль состояния устройств, чтобы пользователи и клиенты получали качественный и актуальный контент. Далее будет описан user flow для администратора киоска.
1 Администратор киосков открывает страницу входа и вводит логин и пароль для доступа к панели управления киосками.
2 После авторизации он попадает на обзорную панель, где отображаются все киоски организации с текущим состоянием: активные, оффлайн, с ошибками, с доступным или устаревшим контентом.
3 Пользователь может добавить новый киоск. Для этого открывается форма, где нужно указать название, местоположение, сетевые настройки, тип контента и другие параметры. После сохранения новый киоск появляется в общем списке и готов к работе.
4 Для существующих киосков администратор открывает форму редактирования и изменяет необходимые параметры: обновляет программное обеспечение, корректирует настройки отображения контента и сохраняет изменения.
5 Если киоск больше не нужен, администратор выбирает его и удаляет. Система запрашивает подтверждение, чтобы предотвратить случайное удаление, после чего киоск удаляется из системы.
6 Пользователь может просматривать текущее состояние киосков, проверять активность контента, сетевые подключения и логи работы устройств для диагностики проблем.
7 Администратор формирует отчёты по выбранным киоскам, включая данные о состоянии, ошибках, обновлениях и активности контента. Отчёты можно скачать для анализа и передачи руководству.
8 После завершения всех действий администратор выходит из системы, завершая сеанс работы.
Ниже представлена диаграмма user flow для системного администратора на рисунке 2.


<img width="974" height="339" alt="image" src="https://github.com/user-attachments/assets/a1a9a18c-c918-423f-9160-15042337f7b8" />


Следующая роль, которая представлена в системе, редактор контента. Цель роли: Редактор контента отвечает за подготовку, организацию и публикацию материалов на киосках. Он загружает новые файлы, редактирует метаданные, создаёт плейлисты и планирует публикации на определённых устройствах. Эта роль обеспечивает, что контент отображается корректно, вовремя и в нужных местах. Основная цель роли – гарантировать, что на киосках всегда актуальная и правильно организованная информация для конечных пользователей, а процесс публикации автоматизирован и управляем.
1 Редактор контента входит в систему, вводя свои учетные данные для доступа к панели управления контентом.
2 После авторизации он попадает на главную панель, где отображается текущий контент, расписание публикаций, доступные плейлисты и уведомления о новых материалах.
3 Пользователь открывает библиотеку контента и просматривает загруженные материалы. Контент отсортирован по категориям и типам, что позволяет быстро находить нужные материалы.
4 Редактор загружает новый контент: выбирает файлы, добавляет описание, категории, ключевые метаданные. После загрузки материалы становятся доступными для использования в плейлистах и публикации на киосках.
5 Далее пользователь создаёт плейлист, добавляя выбранные материалы. Плейлист сохраняется и становится доступным для планирования публикаций.
6 Для публикации контента редактор открывает планировщик, выбирает киоски, задаёт дату и время публикации и подтверждает отправку. Система автоматически распределяет контент на выбранные устройства.
7 После публикации редактор может выполнить предпросмотр, чтобы убедиться, что контент корректно отображается на киосках, все метаданные верны, а видео и изображения воспроизводятся правильно.
8 После завершения всех действий редактор выходит из системы, закрывая сеанс работы.
Далее представлена диаграмма user-flow на рисунке 3.

<img width="771" height="455" alt="image" src="https://github.com/user-attachments/assets/eb916750-24a7-4cdc-bd73-24ee89e1f3b2" />

Следующая роль, которая представлена в системе, техник. Цель роли:
Техник отвечает за обслуживание и диагностику киосков на местах или удалённо. Он проводит проверку состояния устройств, выявляет неисправности, выполняет удалённое управление, перезагрузку или собирает логи для анализа. Также техник планирует обновления программного обеспечения и фиксирует результаты своих действий в отчётах. Основная цель роли – обеспечить бесперебойную работу киосков и быстрое устранение технических проблем, минимизируя время простоя устройств.
Далее представлено описание user-flow. 
1 Техник входит в систему и попадает на панель с текущими заданиями и тикетами на обслуживание киосков.
2 Пользователь просматривает список заданий и выбирает киоск, который необходимо обслужить.
3 Техник запускает диагностику выбранного киоска с помощью удаленного мониторинга: проверяет состояние устройства, работоспособность контента, подключение к сети и ошибки системы.
4 В зависимости от результата диагностики:
Если киоск неисправен, техник выполняет необходимые действия: удалённое управление, перезагрузку устройства, сбор логов для последующего анализа.
Если киоск исправен, техник планирует обновление программного обеспечения для поддержания актуальности и безопасности.
5 После выполнения всех действий техник создаёт отчёт, в котором фиксирует состояние киоска, выполненные операции, выявленные ошибки и рекомендации.
6 Техник закрывает тикет и возвращается к списку заданий для выполнения следующих операций.
7 После выполнения всех задач техник выходит из системы, завершив рабочий сеанс.
Далее представлена диаграмма user-flow на рисунке 4.


<img width="479" height="654" alt="image" src="https://github.com/user-attachments/assets/780d4d30-3662-4746-9ca2-071a90dc016f" />


Следующая роль, которая представлена в системе, оператор поддержки.
Цель роли: Оператор поддержки отвечает за обработку инцидентов и обращений, связанных с работой киосков. Он просматривает очередь тикетов, выбирает конкретные инциденты для обработки, решает их самостоятельно или эскалирует к технику. Также оператор фиксирует результаты работы и формирует отчёты. Основная цель роли – поддерживать бесперебойную работу киосков, оперативно решать проблемы пользователей и обеспечивать корректную работу системы поддержки.
Далее представлено описание user-flow. 
1 Оператор поддержки входит в систему и попадает на панель с очередью инцидентов и тикетов.
2 Пользователь просматривает список инцидентов, сортируя их по приоритету, дате создания или типу проблемы.
3 Оператор выбирает конкретный инцидент для обработки.
4 В зависимости от характера проблемы оператор решает, нужна ли эскалация:
Если требуется вмешательство техника, он передаёт задачу и фиксирует информацию о передаче.
Если эскалация не требуется, выполняет автоматическое решение или перезапуск системы для устранения проблемы.
5 После решения инцидента оператор закрывает тикет и фиксирует результат обработки.
6 При необходимости формирует отчёты о работе с инцидентами, включая количество закрытых тикетов, причины обращений и результаты обработки.
7 Возвращается к очереди инцидентов для обработки новых задач.
8 После завершения всех действий оператор выходит из системы.
Далее представлена диаграмма user-flow на рисунке 5.

<img width="730" height="881" alt="image" src="https://github.com/user-attachments/assets/4a683b26-8ad6-424c-a3ea-d7a04dc05935" />


Следующая роль, которая представлена в системе, аналитик. Цель роли:
Аналитик отвечает за сбор, обработку и анализ данных о работе киосков и контента. Он формирует отчёты, строит визуализации и графики, чтобы оценить эффективность работы устройств, публикаций и активности пользователей. Также он планирует автоматическую генерацию отчётов для регулярного контроля. Основная цель роли – предоставить руководству и ответственным сотрудникам точную информацию для принятия решений, улучшения работы системы и оптимизации процессов управления контентом и устройствами.
1 Пользователь входит в систему и получает доступ к панели аналитики.
2 На панели аналитики отображается информация о состоянии всех киосков, активности контента, публикациях и ошибках.
3 Пользователь выбирает тип отчёта для анализа: отчёт по контенту, по состоянию киосков или по активности пользователей.
4 Отфильтровывает данные по критериям: временной период, конкретные киоски, категории контента и другие параметры.
5 Генерирует отчёт и просматривает визуализации, графики и диаграммы для анализа эффективности работы киосков.
6 При необходимости экспортирует отчёт в PDF или CSV, чтобы передать его руководству или использовать в презентации.
7 Планирует автоматическое формирование отчётов на регулярной основе, чтобы получать актуальные данные без ручного вмешательства.
8 После завершения всех операций пользователь выходит из системы, закрывая сеанс работы.
Далее представлена диаграмма user-flow на рисунке 6.

<img width="547" height="725" alt="image" src="https://github.com/user-attachments/assets/202abb6b-b6b9-466a-a8ff-9e8745082c60" />



## Детали реализации

# Распространённые ошибки при разработке на Laravel

Разработка на Laravel даёт множество встроенных инструментов для ускорения работы. Однако именно из-за этого программисты часто допускают ошибки, которые приводят к некачественному коду. Наиболее распространённые из них связаны с:  

- Перегрузкой контроллеров  
- Дублированием логики  
- Неправильной работой с базой данных  
- Отсутствием обработки ошибок  
- Нарушением архитектурных принципов  

Часто вся логика — от валидации входных данных и бизнес-правил до взаимодействия с базой и отправки уведомлений — пишется в одном методе. Такой код трудно поддерживать и тестировать.  

```php
public function store(Request $request)
{
    if (!$request->has('email')) {
        return response()->json(['error' => 'Email is required'], 400);
    }

    $user = new User();
    $user->name = $request->input('name');
    $user->email = $request->input('email');
    $user->save();

    Mail::to($user->email)->send(new WelcomeMail($user));

    return response()->json(['message' => 'User created']);
}

```

Исправление заключается в разделении ответственности. Валидацию стоит вынести в отдельный FormRequest, бизнес-логику – в сервисный слой, а отправку писем – в очередь.

```php
// Хороший код
public function store(CreateUserRequest $request, UserService $service)
{
    $user = $service->createUser($request->validated());
    return response()->json(['message' => 'User created']);
}

```

Не менее частой ошибкой является дублирование кода. В приложениях для администрирования киосков, например, активация и деактивация может повторяться в разных контроллерах.

```php
// Плохой код
$user->status = 'inactive';
$user->save();

$kiosk->status = 'inactive';
$kiosk->save();

```

Чтобы избежать повторов, стоит вынести логику в общий метод.

```php
// Хороший код
public function deactivate(Model $entity)
{
    $entity->status = 'inactive';
    $entity->save();
}

```

Серьёзной проблемой является неэффективная работа с базой данных. Одной из типичных ошибок считается загрузка всех записей через Model::all(), даже если нужно обработать миллионы строк.

```php
// Плохой код
$logs = LogEntry::all();
foreach ($logs as $log) {
    // обработка
}
```

Это приводит к утечке памяти. Более эффективный подход – использовать chunk:

```php
// Хороший код
LogEntry::chunk(500, function ($logs) {
    foreach ($logs as $log) {
        // обработка
    }
});

```

Другая проблема связана с так называемой ошибкой N+1 запросов. Она возникает, когда для каждой записи делается отдельный запрос к связанным данным.

```php
// Плохой код
$users = User::all();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Laravel при этом выполняет десятки дополнительных запросов. Исправление заключается в использовании жадной загрузки:

```php
// Хороший код
$users = User::with('profile')->get();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Проблемой можно назвать и отсутствие обработки ошибок. Например, попытка получить пользователя по ID без проверки может привести к фатальной ошибке:

```php
// Плохой код
$user = User::find($id);
return $user->email;
```

Гораздо лучше обрабатывать ситуации, когда объект не найден:

```php
// Хороший код
$user = User::find($id);
if (!$user) {
    return response()->json(['error' => 'User not found'], 404);
}
return $user->email;
```

Часто встречается и плохой нейминг функций и переменных. Код с названиями вроде doIt($a, $b) непонятен даже автору спустя время.

```php
// Плохой код
function doIt($a, $b) {
    return $a + $b;
}
```

Хорошее название делает код самодокументируемым:

```php
// Хороший код
function calculateInvoiceTotal($subtotal, $tax) {
    return $subtotal + $tax;
}
```

Ещё одна распространённая ошибка – использование временных переменных, которые не добавляют смысла.

```php
// Плохой код
$tmp = $request->input('location');
$kiosk->location = $tmp;
```

Запись можно упростить:

```php
// Хороший код
$kiosk->location = $request->input('location');

Отдельно стоит выделить захардкоденные значения в коде. Например:

```php
// Плохой код
if ($user->role === 'admin') {
    // особая логика
}
```

Лучше использовать константы или конфиги:

```php
// Хороший код
if ($user->role === User::ROLE_ADMIN) {
    // особая логика
}
```

# Распространённые проблемы и ошибки при разработке на Angular

Во фронтенд-разработке на Angular можно встретить похожие по сути проблемы, что и в Laravel, но проявляются они по-своему. Основная из них связана с перегруженными компонентами.  

Разработчики часто помещают и бизнес-логику, и работу с API, и управление состоянием прямо в компонент. Такой подход затрудняет сопровождение и тестирование.  

---

```typescript
/Плохой пример
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users: any[] = [];
  constructor(private http: HttpClient) {
    this.http.get<any[]>('/api/users').subscribe(data => {
      this.users = data.filter(u => u.active);
    });
  }
}
```

Лучшим решением является вынесение логики работы с данными в отдельный сервис, а компонент должен только подписываться на поток данных.

```typescript
// Хороший код (разделение обязанностей)
@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}
  getActiveUsers() {
    return this.http.get<User[]>('/api/users')
      .pipe(map(users => users.filter(u => u.active)));
  }
}
```
```typescript
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users$ = this.userService.getActiveUsers();
  constructor(private userService: UserService) {}
}
```

Другая распространённая ошибка связана с утечками памяти из-за отсутствия отписки от подписок. Когда в компоненте используется subscribe, но отписка в ngOnDestroy не реализована, память продолжает удерживать подписки даже после удаления компонента.

```typescript
// Плохой код (подписка без отписки)
ngOnInit() {
  this.http.get('/api/data').subscribe(result => {
    this.data = result;
  });
}
```

Исправлением является либо явная отписка с помощью Subject и takeUntil, либо использование async pipe, который сам управляет подпиской.

```typescript
// Хороший код (async pipe)
data$ = this.http.get('/api/data');
<div *ngIf="data$ | async as data">
  {{ data }}
</div>
```

Часто встречается и проблема слишком сложной логики прямо в шаблонах. Например:

```typescript
<!-- Плохой код -->
<div>{{ users.filter(u => u.active).map(u => u.name).join(', ') }}</div>
```

Каждый цикл изменения состояния Angular будет заново выполнять фильтрацию и объединение строк, что негативно сказывается на производительности. Логичнее вынести подготовку данных в компонент:

```typescript
// Хороший код
activeUserNames = '';
ngOnInit() {
  this.userService.getActiveUsers().subscribe(users => {
    this.activeUserNames = users.map(u => u.name).join(', ');
  });
}

<div>{{ activeUserNames }}</div>

```

Неудачные имена переменных и методов также характерны для Angular. Код с переменными вроде d, arr, tmp становится нечитаемым:

```typescript
// Плохой код
let d = this.http.get('/api/kiosks');

```

Понятные названия делают код самодокументируемым:

```typescript
let kiosks$ = this.http.get<Kiosk[]>('/api/kiosks');
```

В Angular иногда встречается и чрезмерное использование any, что убивает преимущества TypeScript.

```typescript
// Плохой код
users: any[] = [];
```

Гораздо правильнее использовать строгую типизацию:

```typescript
// Хороший код
users: User[] = [];
```

Оптимизационные ошибки также играют важную роль. Например, использование *ngFor без ключа trackBy при больших списках приводит к тому, что Angular каждый раз пересоздаёт все элементы при малейшем изменении.

```typescript
<!-- Плохой код -->
<li *ngFor="let user of users">{{ user.name }}</li>
```

Гораздо лучше использовать trackBy, чтобы Angular понимал, какие элементы изменились, а какие остались прежними.

```typescript
<!-- Хороший код -->
<li *ngFor="let user of users; trackBy: trackById">{{ user.name }}</li>

trackById(index: number, item: User) {
  return item.id;
}
```

Неоптимальная работа с состоянием приложения также относится к типичным проблемам. Хранение сложных состояний прямо в компонентах затрудняет развитие кода. Лучшим решением является использование централизованного управления состоянием (NgRx или аналогичных решений).










### UML-диаграммы


В ходе разработки программного средства для администрирования распределённых информационных киосков организации были созданы несколько UML-диаграмм, отражающих как статическую, так и динамическую структуру проектируемой системы.
Каждая диаграмма выполняет свою роль в моделировании архитектуры и логики функционирования программного комплекса.
Первой разработанной диаграммой, описание которой представлено ниже. Диаграмма вариантов использования относится к динамическим диаграммам, так как описывает поведение системы с точки зрения взаимодействия внешних акторов с системой. На ней представлены основные пользователи – администратор и информационный киоск – а также совокупность прецедентов, реализующих ключевые функции: авторизация, управление киосками, редактирование и обновление контента, мониторинг состояния устройств, резервное копирование и формирование отчётов.
Данная диаграмма отражает границы системы и описывает, какие функции доступны пользователям и как они связаны между собой через отношения include и extend.

<img width="974" height="667" alt="image" src="https://github.com/user-attachments/assets/ab407368-b379-4bac-914d-cc5f95654b42" />

Данная диаграмма демонстрирует взаимодействие двух основных акторов – администратора и киоска – с системой, а также показывает взаимосвязь между различными вариантами использования, включающими операции управления, обновления, мониторинга и обмена данными.
Центральной фигурой является администратор, который взаимодействует с системой через веб-интерфейс, выполняя административные функции. Диаграмма показывает, что его работа начинается с процесса авторизации в системе, который выступает базовым действием и включается во все остальные сценарии, требующие проверки прав доступа. Авторизация является обязательной предусловием для любых операций изменения или мониторинга, что подчёркивает безопасность системы. После успешного входа администратор получает возможность просматривать список киосков, мониторить сеть, редактировать данные устройств, управлять контентом и расписаниями обновлений, а также работать с отчётами.
Далее, диаграмма показывает логику взаимодействий между действиями. Операция добавления нового киоска включает прецедент регистрации киоска в системе, что означает создание новой записи об устройстве, привязку к сети и настройку базовых параметров для последующей работы. Аналогично, удаление киоска расширяет прецедент просмотра списка – то есть выполняется из того же интерфейса, когда администратор уже видит текущее состояние устройств.
Функциональность, связанная с поддержанием и обновлением контента, представлена группой взаимосвязанных прецедентов, объединённых логикой управления контентом. Администратор может загрузить новый контент, обновить существующий, удалить устаревший и инициировать развёртывание контента на киосках. Развёртывание связано как с действием администратора, так и с самим киоском: после отправки задачи устройства принимают пакет обновления, проверяют корректность файлов и выполняют установку. Если во время обновления возникает сбой, активируется дополнительный прецедент отправки уведомления об ошибке, что расширяет сценарий развёртывания. Таким образом, система поддерживает механизм автоматического уведомления и контроля корректности операций.
Отдельная логическая ветвь на диаграмме связана с мониторингом сети киосков. Этот вариант использования подразумевает сбор системных данных о состоянии устройств, уровне их доступности и успешности обновлений. Прецедент мониторинга включает в себя получение отчётов от киосков, представленных в диаграмме как прецедент отправки отчёта о состоянии. Это действие инициируется киосками автоматически, без участия администратора, и служит для обновления информации о текущем состоянии оборудования. Если отчёты содержат данные о неудачных обновлениях или сбоях, система может активировать расширяющий прецедент отправки уведомления об ошибке.
Также предусмотрен функционал просмотра логов и отчётов, который расширяет возможности мониторинга и позволяет администратору анализировать историю действий и результаты операций. Через эту часть системы администратор может видеть последовательность установок контента, ошибки и время выполнения задач, что важно для контроля и диагностики.
Управление пользователями включено в диаграмму как отдельный прецедент, однако он логически связан с авторизацией. Это означает, что только пользователь с соответствующими правами может добавлять или редактировать учётные записи других администраторов. Этот элемент подчёркивает безопасность и разграничение прав доступа внутри системы.
На стороне киоска отображены три ключевых варианта использования: передача отчётов, выполнение обновлений и отправка уведомлений об ошибке. Эти действия выполняются автоматически при взаимодействии устройства с сервером. Киоск получает команды от системы, загружает необходимые пакеты контента, применяет обновления и после завершения отправляет отчёт с результатами. Если установка завершается сбоем, автоматически формируется уведомление об ошибке, которое поступает на сервер администратора. Такое разделение ролей демонстрирует, что киоск не является пассивным элементом, а активно участвует в процессе обмена данными и поддерживает обратную связь с системой.
На диаграмме чётко обозначены связи include и extend, которые отражают внутреннюю логику процессов. Связи include указывают на обязательность выполнения подэтапов – например, регистрация киоска входит в добавление нового устройства, а авторизация является частью любой административной операции. Связи extend обозначают условные или дополнительные действия, которые выполняются при определённых обстоятельствах, например, удаление киоска расширяет просмотр списка, а уведомление об ошибке расширяет развёртывание контента. Это позволяет показать, какие процессы выполняются всегда, а какие активируются только при возникновении исключительных ситуаций.
Таким образом, диаграмма вариантов использования отражает полную картину взаимодействия между пользователем и системой. Она демонстрирует, что основная цель программного средства заключается в централизованном управлении сетью информационных киосков – от регистрации и обновления устройств до мониторинга их состояния и анализа отчётности. Диаграмма показывает баланс между автоматическими процессами (на стороне киосков) и действиями администратора, а также подчёркивает важность контроля, прозрачности и безопасности всех операций.
Далее нужно описать диаграмму классов данная диаграмма классов представляет собой детализированную модель структуры программного средства для администрирования распределённых информационных киосков организации. Она отражает все основные сущности системы, их атрибуты, методы и взаимосвязи, демонстрируя логику работы приложения и распределение ответственности между компонентами. Основная идея диаграммы заключается в том, чтобы показать, как административная часть системы взаимодействует с сетью физических киосков, обеспечивая централизованное управление контентом, мониторинг состояния устройств и обработку возникающих событий. 


<img width="974" height="939" alt="image" src="https://github.com/user-attachments/assets/a326a919-517c-431b-91f0-01747dde96af" />


В центре системы находится класс AdminUser, который представляет администратора, управляющего всей сетью киосков. Этот класс содержит основные атрибуты, такие как идентификатор пользователя, имя, хэш пароля, адрес электронной почты и роль, определяющую уровень доступа. Методы класса, включая login(), logout(), createKiosk(), assignContent() и viewLogs(), отражают типичные действия администратора – авторизацию, создание и настройку киосков, назначение контента для отображения, а также просмотр логов работы системы. Именно через этот класс реализуется контроль над инфраструктурой киосков, что обуславливает его прямые связи с несколькими другими классами. Связь между AdminUser и Kiosk показывает, что один администратор может управлять множеством киосков, добавляя новые устройства, редактируя их параметры или удаляя устаревшие. Аналогично, связь между AdminUser и Content отражает право администратора добавлять и редактировать мультимедийные материалы, которые впоследствии будут транслироваться на экранах киосков. Также администратор связан с классами DeploymentTask и Schedule, что подчёркивает его полномочия по созданию задач обновления контента и планированию этих операций во времени.
Класс Kiosk представляет собой программно-аппаратный терминал, размещённый на объекте организации. Он содержит конкретные характеристики, включая идентификатор, название, местоположение, IP-адрес, текущий статус и время последнего выхода в сеть. Методы receiveContent(), sendReport() и sendError() показывают, что киоск способен принимать контент, передавать отчёты о своём состоянии и отправлять уведомления об ошибках. Связь между Kiosk и KioskStatus реализуется через перечисление, фиксирующее возможные состояния устройства: активный, оффлайн, с ошибкой или в режиме обслуживания. Это позволяет системе отслеживать техническое состояние каждого киоска и своевременно реагировать на проблемы. Киоски могут быть объединены в логические группы, что отражено через связь с классом KioskGroup. Такая группировка упрощает массовое управление, например, когда администратор назначает одинаковый контент всем киоскам определённого подразделения.
Класс Content описывает объекты мультимедийного контента, который отображается на экранах киосков. Он включает поля, такие как идентификатор, заголовок, тип, версия, путь к файлу, дата загрузки и размер. Методы upload(), updateVersion() и delete() обеспечивают полный жизненный цикл контента от загрузки до удаления. Связь между Content и DeploymentTask указывает, что каждая задача развёртывания связана с конкретным контентом, который необходимо доставить на киоски. Таким образом, DeploymentTask становится связующим звеном между контентом и группами устройств.
Класс DeploymentTask представляет собой задачу на выполнение определённых действий, например, обновление контента или конфигурации на группе киосков. Он содержит атрибуты, описывающие идентификатор, время создания, статус выполнения и результат. Методы execute(), rollback() и checkStatus() позволяют управлять процессом выполнения и отслеживать его текущее состояние. Связь с перечислением TaskStatus даёт системе возможность фиксировать, на каком этапе находится задача – в ожидании, выполняется, завершена или завершилась ошибкой. Ассоциация между DeploymentTask и KioskGroup объясняется тем, что одна задача может выполняться одновременно на множестве киосков, принадлежащих одной или нескольким группам. Связь с классом Schedule показывает, что выполнение задач может быть автоматизировано с помощью планировщика, который запускает их в заранее определённое время.
Класс Schedule отвечает за планирование периодических операций в системе. Он содержит атрибуты с выражением CRON, указывающим расписание, флаг активности и время следующего запуска. Через методы planTask() и disable() администратор может включать и отключать автоматические задачи. Эта связь с DeploymentTask показывает, что расписание создаёт и контролирует выполнение определённых действий по обновлению контента.
Система также предусматривает сбор информации о состоянии киосков. Класс Report используется для формирования отчётов, которые киоск отправляет на сервер. Он включает данные об идентификаторе устройства, времени формирования, времени бесперебойной работы, количестве ошибок и текстовых деталях. Метод generateSummary() агрегирует информацию, создавая краткий отчёт для администратора. Параллельно работает класс LogRecord, который сохраняет внутренние события системы, включая время, уровень логирования, сообщение и источник. Эти данные используются для аудита и диагностики.
Класс ErrorNotification отражает механизм уведомления об ошибках. Каждый киоск при возникновении неисправности создаёт объект этого типа и отправляет его администратору. В нём фиксируются идентификатор киоска, временная метка, код ошибки и описание. Метод sendToAdmin() моделирует передачу уведомления в административную панель или по электронной почте.
Класс SystemSettings хранит параметры конфигурации всей системы. Его поля включают название параметра и значение, а метод updateSetting() обеспечивает изменение конфигурации без перезапуска приложения. Связь между SystemSettings и Kiosk отражает то, что каждая настройка может влиять на поведение нескольких киосков, например, изменять частоту обновления или формат отчётов.
Таким образом, диаграмма демонстрирует чёткую архитектуру распределённой системы, где AdminUser выступает управляющим центром, а Kiosk – периферийным узлом, взаимодействующим через задачи, отчёты и уведомления. Content, DeploymentTask и Schedule образуют функциональный цикл обновления контента, обеспечивая актуальность информации на киосках. KioskGroup упрощает масштабное администрирование, LogRecord, Report и ErrorNotification отвечают за мониторинг и обратную связь, а SystemSettings обеспечивает гибкую настройку. Такая структура обеспечивает расширяемость, надёжность и прозрачность управления, что делает её оптимальной для программного средства администрирования распределённых информационных киосков.
Диаграмма деятельности относится к динамическим UML-диаграммам, поскольку описывает последовательность действий и поток управления при выполнении бизнес-процессов системы. Она отражает этапы процесса обновления контента на киосках: от подготовки пакета контента и определения целевых устройств до проверки ресурсов, установки, контроля контрольной суммы и регистрации события аудита.
Данная диаграмма позволяет визуализировать логику работы системы и распределение ответственности между участниками процесса – администратором, сервером и самим киоском. 


<img width="2056" height="4041" alt="Диаграмма деятельности 3 лаба риопк drawio" src="https://github.com/user-attachments/assets/aec2f6c4-9298-45aa-968a-4227b44f92e9" />

Процесс начинается с того, что администратор открывает веб-панель и пытается войти в систему; если аутентификация успешна, интерфейс загружает список доступных киосков и последние отчёты, если нет – система возвращает ошибку и просит повторить вход или восстановить пароль. После успешного входа администратор выбирает цель – либо подготовить новый пакет контента для загрузки, либо выбрать уже существующий пакет и задать параметры развёртывания; при подготовке пакета администратор прикрепляет файлы, задаёт метаданные (версия, категория, критичность) и, при необходимости, указывает группу киосков или конкретные устройства. Как только пакет сформирован, администратор выбирает режим – немедленное развёртывание или создание расписания; при выборе расписания система запрашивает выражение CRON и сохраняет задание в планировщик. Если развёртывание назначено немедленно или запущено планировщиком, сервер выполняет предварительную валидацию пакета: проверяет целостность файлов (контрольные суммы), соответствие форматов и доступность файлового хранилища; в случае ошибки валидации процесс останавливается и администратор получает уведомление с описанием проблемы, при успешной валидации сервер регистрирует задачу развёртывания и помещает её в очередь задач. Следующим шагом сервер вычисляет таргет-список устройств и для каждого устройства проверяет текущее состояние: если киоск находится офлайн, система помечает устройство как отложенное и отправляет уведомление администратору о частичной недостижимости; если киоск онлайн, сервер отправляет команду на начало загрузки пакета вместе с адресом хранения и контрольной суммой. На стороне киоска агент получает команду, инициирует загрузку и параллельно может выполнять проверку доступного места и запущенных процессов; при нехватке ресурсов киоск возвращает подробный код ошибки и лог, после чего сервер помечает задачу для этого киоска как «failed» и, в зависимости от настроек задачи, либо инициирует попытку ретрая, либо оповещает администратора. Если скачивание прошло успешно, киоск выполняет проверку контрольной суммы, распаковку и установку контента; в момент установки киоск переключает локальные сервисы в режим обновления, чтобы избежать отображения неконсистентного контента. По завершении установки киоск формирует отчёт с результатом (success/failure), временем операции и сопутствующими логами и отправляет его на сервер. Сервер агрегирует ответы от всех целевых устройств, обновляет статус DeploymentTask (RUNNING → COMPLETED, или RUNNING → PARTIAL_FAILED/FAILED), сохраняет логи в центральное хранилище и, при обнаружении ошибок, запускает компенсирующие действия: по конфигурации это может быть автоматический rollback до предыдущей версии на поражённых киосках или создание уведомления/тикета для ручной проверки. Администратор получает итоговую сводку по задаче с возможностью просмотреть детальные логи по каждому киоску, инициировать повторный запуск задачи для неудачных устройств, сформировать поддержку и пометить киоск для физической проверки. В параллельной ветви системы работают мониторинг и уведомления: NetworkMonitor периодически пингует устройства и генерирует ErrorNotification при длительной недоступности, отчёты от киосков периодически попадают в систему и обновляют дашборд мониторинга, а AuditEvent фиксирует все критические операции администратора (создание задач, откаты, изменение расписаний) для последующего аудита. В завершение администратор может вручную убедиться в консистентности контента, скорректировать настройки SystemSettings или запустить BackupTask для сохранения текущей конфигурации и метаданных, после чего процесс считается завершённым; при этом любые незавершённые или отложенные задачи остаются в очереди и обрабатываются согласно политике ретраев или расписанию.
Диаграмма состояний также относится к динамическим диаграммам UML, так как описывает жизненный цикл объекта и его переходы между состояниями в зависимости от событий. В качестве основного объекта моделирования выбран информационный киоск, поведение которого изменяется в зависимости от взаимодействия с сервером и выполнения внутренних процессов.
Диаграмма отображает такие состояния, как «Ожидание подключения», «Активен», «Оффлайн», «Ожидание пакета», «Установка пакета», «Ошибка установки», «Резервное копирование» и «Неактивен».
Каждый переход между состояниями инициируется определённым событием – например, командой администратора, завершением установки или возникновением ошибки.

<img width="820" height="830" alt="image" src="https://github.com/user-attachments/assets/24d17942-68d7-470f-824e-1c4731bb458e" />


### Спецификация API

### Безопасность

В ходе работы была реализована полноценная система аутентификации и авторизации пользователей программной системы на основе Laravel (backend) и Vue.js (frontend). Целью реализации было обеспечение безопасного доступа пользователей к функционалу системы, разграничение прав и защита передаваемых данных.
На стороне сервера аутентификация реализована с использованием фреймворка Laravel Sanctum, который предоставляет лёгкий механизм для выдачи и проверки персональных токенов доступа. В процессе регистрации пользователь создаёт учётную запись, данные которой сохраняются в базе данных. Для безопасного хранения паролей используется встроенный механизм Laravel – хэширование через bcrypt, что исключает возможность хранения паролей в открытом виде. При входе пользователь передаёт email и пароль, которые сверяются с записями в базе. После успешной проверки создаётся токен авторизации, который возвращается клиенту. Этот токен сохраняется в localStorage на фронтенде и прикрепляется к каждому последующему запросу в виде заголовка Authorization: Bearer <token>.
Для выхода из системы реализован специальный маршрут /logout, который аннулирует токен пользователя, делая дальнейшее использование его недействительным. Таким образом, обеспечивается контроль за активными сессиями и предотвращается несанкционированный доступ после выхода.
На фронтенде с помощью Pinia создано хранилище auth.js, в котором сохраняются данные о текущем пользователе и токене. При авторизации состояние обновляется, а компонент интерфейса реагирует на это изменением кнопки –  после успешного входа надпись «Войти» меняется на “Выйти”. При нажатии на кнопку «Выйти» вызывается метод logout, который очищает токен, удаляет пользователя из состояния и сбрасывает заголовки Authorization.
Для защиты маршрутов на клиенте используется проверка авторизации: если пользователь не вошёл в систему, он не может получить доступ к закрытым страницам. Это реализовано как через Pinia-геттер isAuthenticated, так и через роутер Vue, который перенаправляет неавторизованных пользователей на страницу входа.
В процессе реализации были внесены изменения в архитектуру проекта: добавлены маршруты /login, /register, /logout и /user в Laravel, а также соответствующие компоненты во фронтенде. Были добавлены формы регистрации и входа, обработка ошибок при неверных данных и динамическое обновление интерфейса в зависимости от состояния пользователя.
Механизмы обеспечения безопасности включают в себя использование HTTPS (при деплое), защиту CSRF-токенами (по умолчанию в Laravel), хэширование паролей, а также разграничение прав доступа через middleware auth:sanctum. Все запросы, требующие авторизации, доступны только при наличии действительного токена. Это гарантирует, что только авторизованные пользователи могут выполнять определённые действия –  например, управлять своими данными или получать доступ к защищённым ресурсам.



### Оценка качества кода

## Тестирование

### Unit-тесты

### Интеграционные тесты

## Установка и запуск

### Манифесты для сборки docker образов

### Манифесты для развертывания k8s кластера

## Лицензия

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]


## Контакты

Автор: email

+375291965762 Елизавета
