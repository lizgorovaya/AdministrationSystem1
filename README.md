# Программное средство для администрирования распределенных информационных киосков организации

Описание проекта: Проект представляет собой программное средство для администрирования распределённых информационных киосков организации. Система предназначена для централизованного управления сетью киосков, которые предоставляют пользователям доступ к различным информационным и интерактивным сервисам. Основной задачей проекта является упрощение процесса администрирования, мониторинга и обновления контента на всех устройствах, что обеспечивает их стабильную работу и актуальность предоставляемой информации.

Цели проекта: Главная цель проекта — повышение эффективности управления распределёнными информационными киосками. Система позволит сократить время и ресурсы, затрачиваемые на обслуживание оборудования, упростить процесс обновления программного обеспечения и контента, а также обеспечить высокий уровень контроля за работой киосков в режиме реального времени.

Основные возможности: Программное средство предоставляет централизованное управление сетью киосков, позволяя администраторам контролировать их состояние, обновлять программное обеспечение и контент, управлять пользователями и их правами доступа. Система формирует аналитические отчёты и статистику работы киосков, что способствует оптимизации их использования. Кроме того, она обеспечивает автоматическую отправку уведомлений о неисправностях и сбоях, что позволяет быстро реагировать на проблемы. Решение отличается высокой надёжностью, безопасностью данных и возможностью масштабирования при увеличении количества устройств.

**Front:** [GitHub репозиторий](https://github.com/lizgorovaya/ADMFront)  
**Back:** [GitHub репозиторий](https://github.com/lizgorovaya/ADMBack)


## Содержание

1. [Архитектура](#архитектура)  
   i. [C4-модель](#c4-модель)  
   ii. [Схема данных](#схема-данных)  

2. [Функциональные возможности](#функциональные-возможности)  
   i. [Диаграмма вариантов использования](#диаграмма-вариантов-использования)  
   ii. [User-flow диаграммы](#user-flow-диаграммы)  

3. [Детали реализации](#детали-реализации)  
   i. [UML-диаграммы](#uml-диаграммы)  
   ii. [Спецификация API](#спецификация-api)  
   iii. [Безопасность](#безопасность)  
   iv. [Оценка качества кода](#оценка-качества-кода)  

4. [Тестирование](#тестирование)  
   i. [Unit-тесты](#unit-тесты)  
   ii. [Интеграционные тесты](#интеграционные-тесты)  

5. [Установка и запуск](#установка-и-запуск)  
   i. [Манифесты для сборки docker образов](#манифесты-для-сборки-docker-образов)  
   ii. [Манифесты для развертывания k8s кластера](#манифесты-для-развертывания-k8s-кластера)  

6. [Лицензия](#лицензия)  
7. [Контакты](#контакты)




## Архитектура

### C4-модель


Модель C4 важна при построении архитектуры программных систем, так как она позволяет наглядно и поэтапно описывать структуру проекта на разных уровнях абстракции. С её помощью можно показать, как система взаимодействует с внешними пользователями и другими системами, из каких контейнеров (приложений, сервисов, баз данных) она состоит, как устроены её внутренние компоненты и каким образом реализован код. На рисунке 1 представлена модель контейнерного уровня С4.

<img width="975" height="631" alt="image" src="https://github.com/user-attachments/assets/6cefd2be-f334-46b0-89e5-44ad8f36fdf5" />

Диаграмма описывает систему взаимодействия пользователей с программным средством администрирования инфокиосков, предназначенную для централизованного управления контентом, пользователями и аналитикой. Администратор Брестэнерго управляет системой и пользователями, контролирует работу контент-менеджеров и аналитиков, а также следит за состоянием инфокиосков через веб-сервис администрирования. Контент-менеджер редактирует и обновляет материалы, которые отображаются на инфокиосках, загружает новые данные и корректирует существующий контент. Аналитик просматривает отчёты и статистику использования инфокиосков, получая информацию о посещаемости, активности пользователей и эффективности контента через программное средство.    
Программное средство администрирования является центральным элементом системы, обеспечивая взаимодействие всех пользователей и получая контент от внешних систем, представленных тремя экземплярами инфокиосков. Пользователи работают с веб-сервисом, который, в свою очередь, интегрирован с инфокиосками для актуализации контента, а администратор обеспечивает корректную работу системы и управление ролями. Таким образом, система обеспечивает централизованное управление контентом, контроль доступа и ролей пользователей, получение и отображение аналитических данных и взаимодействие с внешними инфокиосками для поддержания актуальности информации.
Далее представлена компонентный уровень модели С4 для детального представления программного обеспечения внутри одного контейнера. Она показывает, как система организована из отдельных компонентов, какие у них обязанности, как они взаимодействуют друг с другом и с внешними системами. На рисунке 2 представлена модель компонентного уровня модели С4.

<img width="974" height="494" alt="image" src="https://github.com/user-attachments/assets/f055a10b-52f4-4876-843f-028092d4db88" />

В системе выделяется три типа пользователей. Администратор управляет системой и пользователями, назначает роли, контролирует корректность работы контент-менеджеров и аналитиков, а также мониторит работу инфокиосков. Контент-менеджер отвечает за подготовку и публикацию материалов: он редактирует текст, изображения и другие элементы контента, который затем отображается на инфокиосках. Аналитик получает доступ к отчётам и статистике, формируемой системой, что позволяет оценивать эффективность публикаций и активность пользователей. Все пользователи взаимодействуют с системой через веб-приложение, которое служит интерфейсом для выполнения всех задач: управления пользователями, публикации контента и просмотра аналитики.
Веб-приложение представляет собой фронтенд, построенный как клиентское веб-приложение, которое делает запросы к API-сервису. Оно обеспечивает удобный интерфейс и визуализацию данных для всех типов пользователей, управляет навигацией, формами редактирования и представлением отчётов.
API-сервис является центральным компонентом backend. Он обрабатывает запросы веб-приложения, управляет пользователями и ролями, хранит и обновляет контент, собирает и обрабатывает журналы посещений от инфокиосков. Кроме того, API-сервис реализует бизнес-логику и маршрутизацию данных между компонентами системы, обеспечивая целостность и согласованность информации.
База данных MySQL хранит всю основную информацию: сведения о пользователях, их ролях, опубликованном контенте и журналы посещений инфокиосков. Она служит основным источником данных для API-сервиса и модуля аналитики.
Инфокиоски подключаются к системе через API-сервис. Они получают актуальный контент для отображения и передают обратно журналы посещений и другую статистическую информацию. Это позволяет системе поддерживать контент в актуальном состоянии и собирать данные для анализа.
Модуль аналитики, встроенный в backend, обрабатывает журналы посещений, анализирует активность пользователей и эффективность контента, а затем формирует отчёты, доступные аналитикам через веб-приложение. Модуль позволяет оценивать работу инфокиосков, выявлять популярный контент и принимать управленческие решения.
Таким образом, система реализует полный цикл администрирования и анализа: пользователи через веб-приложение управляют контентом и ролями, API-сервис обеспечивает обработку данных и взаимодействие с базой, инфокиоски получают контент и передают статистику, а модуль аналитики формирует отчёты для оценки эффективности работы системы.

### Схема данных

## Функциональные возможности

### Диаграмма вариантов использования

### User-flow диаграммы

## Детали реализации

# Распространённые ошибки при разработке на Laravel

Разработка на Laravel даёт множество встроенных инструментов для ускорения работы. Однако именно из-за этого программисты часто допускают ошибки, которые приводят к некачественному коду. Наиболее распространённые из них связаны с:  

- Перегрузкой контроллеров  
- Дублированием логики  
- Неправильной работой с базой данных  
- Отсутствием обработки ошибок  
- Нарушением архитектурных принципов  

Часто вся логика — от валидации входных данных и бизнес-правил до взаимодействия с базой и отправки уведомлений — пишется в одном методе. Такой код трудно поддерживать и тестировать.  

```php
public function store(Request $request)
{
    if (!$request->has('email')) {
        return response()->json(['error' => 'Email is required'], 400);
    }

    $user = new User();
    $user->name = $request->input('name');
    $user->email = $request->input('email');
    $user->save();

    Mail::to($user->email)->send(new WelcomeMail($user));

    return response()->json(['message' => 'User created']);
}

```

Исправление заключается в разделении ответственности. Валидацию стоит вынести в отдельный FormRequest, бизнес-логику – в сервисный слой, а отправку писем – в очередь.

```php
// Хороший код
public function store(CreateUserRequest $request, UserService $service)
{
    $user = $service->createUser($request->validated());
    return response()->json(['message' => 'User created']);
}

```

Не менее частой ошибкой является дублирование кода. В приложениях для администрирования киосков, например, активация и деактивация может повторяться в разных контроллерах.

```php
// Плохой код
$user->status = 'inactive';
$user->save();

$kiosk->status = 'inactive';
$kiosk->save();

```

Чтобы избежать повторов, стоит вынести логику в общий метод.

```php
// Хороший код
public function deactivate(Model $entity)
{
    $entity->status = 'inactive';
    $entity->save();
}

```

Серьёзной проблемой является неэффективная работа с базой данных. Одной из типичных ошибок считается загрузка всех записей через Model::all(), даже если нужно обработать миллионы строк.

```php
// Плохой код
$logs = LogEntry::all();
foreach ($logs as $log) {
    // обработка
}
```

Это приводит к утечке памяти. Более эффективный подход – использовать chunk:

```php
// Хороший код
LogEntry::chunk(500, function ($logs) {
    foreach ($logs as $log) {
        // обработка
    }
});

```

Другая проблема связана с так называемой ошибкой N+1 запросов. Она возникает, когда для каждой записи делается отдельный запрос к связанным данным.

```php
// Плохой код
$users = User::all();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Laravel при этом выполняет десятки дополнительных запросов. Исправление заключается в использовании жадной загрузки:

```php
// Хороший код
$users = User::with('profile')->get();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Проблемой можно назвать и отсутствие обработки ошибок. Например, попытка получить пользователя по ID без проверки может привести к фатальной ошибке:

```php
// Плохой код
$user = User::find($id);
return $user->email;
```

Гораздо лучше обрабатывать ситуации, когда объект не найден:

```php
// Хороший код
$user = User::find($id);
if (!$user) {
    return response()->json(['error' => 'User not found'], 404);
}
return $user->email;
```

Часто встречается и плохой нейминг функций и переменных. Код с названиями вроде doIt($a, $b) непонятен даже автору спустя время.

```php
// Плохой код
function doIt($a, $b) {
    return $a + $b;
}
```

Хорошее название делает код самодокументируемым:

```php
// Хороший код
function calculateInvoiceTotal($subtotal, $tax) {
    return $subtotal + $tax;
}
```

Ещё одна распространённая ошибка – использование временных переменных, которые не добавляют смысла.

```php
// Плохой код
$tmp = $request->input('location');
$kiosk->location = $tmp;
```

Запись можно упростить:

```php
// Хороший код
$kiosk->location = $request->input('location');

Отдельно стоит выделить захардкоденные значения в коде. Например:

```php
// Плохой код
if ($user->role === 'admin') {
    // особая логика
}
```

Лучше использовать константы или конфиги:

```php
// Хороший код
if ($user->role === User::ROLE_ADMIN) {
    // особая логика
}
```

# Распространённые проблемы и ошибки при разработке на Angular

Во фронтенд-разработке на Angular можно встретить похожие по сути проблемы, что и в Laravel, но проявляются они по-своему. Основная из них связана с перегруженными компонентами.  

Разработчики часто помещают и бизнес-логику, и работу с API, и управление состоянием прямо в компонент. Такой подход затрудняет сопровождение и тестирование.  

---

```typescript
/Плохой пример
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users: any[] = [];
  constructor(private http: HttpClient) {
    this.http.get<any[]>('/api/users').subscribe(data => {
      this.users = data.filter(u => u.active);
    });
  }
}
```

Лучшим решением является вынесение логики работы с данными в отдельный сервис, а компонент должен только подписываться на поток данных.

```typescript
// Хороший код (разделение обязанностей)
@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}
  getActiveUsers() {
    return this.http.get<User[]>('/api/users')
      .pipe(map(users => users.filter(u => u.active)));
  }
}
```
```typescript
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users$ = this.userService.getActiveUsers();
  constructor(private userService: UserService) {}
}
```

Другая распространённая ошибка связана с утечками памяти из-за отсутствия отписки от подписок. Когда в компоненте используется subscribe, но отписка в ngOnDestroy не реализована, память продолжает удерживать подписки даже после удаления компонента.

```typescript
// Плохой код (подписка без отписки)
ngOnInit() {
  this.http.get('/api/data').subscribe(result => {
    this.data = result;
  });
}
```

Исправлением является либо явная отписка с помощью Subject и takeUntil, либо использование async pipe, который сам управляет подпиской.

```typescript
// Хороший код (async pipe)
data$ = this.http.get('/api/data');
<div *ngIf="data$ | async as data">
  {{ data }}
</div>
```

Часто встречается и проблема слишком сложной логики прямо в шаблонах. Например:

```typescript
<!-- Плохой код -->
<div>{{ users.filter(u => u.active).map(u => u.name).join(', ') }}</div>
```

Каждый цикл изменения состояния Angular будет заново выполнять фильтрацию и объединение строк, что негативно сказывается на производительности. Логичнее вынести подготовку данных в компонент:

```typescript
// Хороший код
activeUserNames = '';
ngOnInit() {
  this.userService.getActiveUsers().subscribe(users => {
    this.activeUserNames = users.map(u => u.name).join(', ');
  });
}

<div>{{ activeUserNames }}</div>

```

Неудачные имена переменных и методов также характерны для Angular. Код с переменными вроде d, arr, tmp становится нечитаемым:

```typescript
// Плохой код
let d = this.http.get('/api/kiosks');

```

Понятные названия делают код самодокументируемым:

```typescript
let kiosks$ = this.http.get<Kiosk[]>('/api/kiosks');
```

В Angular иногда встречается и чрезмерное использование any, что убивает преимущества TypeScript.

```typescript
// Плохой код
users: any[] = [];
```

Гораздо правильнее использовать строгую типизацию:

```typescript
// Хороший код
users: User[] = [];
```

Оптимизационные ошибки также играют важную роль. Например, использование *ngFor без ключа trackBy при больших списках приводит к тому, что Angular каждый раз пересоздаёт все элементы при малейшем изменении.

```typescript
<!-- Плохой код -->
<li *ngFor="let user of users">{{ user.name }}</li>
```

Гораздо лучше использовать trackBy, чтобы Angular понимал, какие элементы изменились, а какие остались прежними.

```typescript
<!-- Хороший код -->
<li *ngFor="let user of users; trackBy: trackById">{{ user.name }}</li>

trackById(index: number, item: User) {
  return item.id;
}
```

Неоптимальная работа с состоянием приложения также относится к типичным проблемам. Хранение сложных состояний прямо в компонентах затрудняет развитие кода. Лучшим решением является использование централизованного управления состоянием (NgRx или аналогичных решений).










### UML-диаграммы

### Спецификация API

### Безопасность

### Оценка качества кода

## Тестирование

### Unit-тесты

### Интеграционные тесты

## Установка и запуск

### Манифесты для сборки docker образов

### Манифесты для развертывания k8s кластера

## Лицензия

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]


## Контакты

Автор: email

+375291965762 Елизавета
