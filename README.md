# Программное средство для администрирования распределенных информационных киосков организации

Описание проекта: Проект представляет собой программное средство для администрирования распределённых информационных киосков организации. Система предназначена для централизованного управления сетью киосков, которые предоставляют пользователям доступ к различным информационным и интерактивным сервисам. Основной задачей проекта является упрощение процесса администрирования, мониторинга и обновления контента на всех устройствах, что обеспечивает их стабильную работу и актуальность предоставляемой информации.

Цели проекта: Главная цель проекта — повышение эффективности управления распределёнными информационными киосками. Система позволит сократить время и ресурсы, затрачиваемые на обслуживание оборудования, упростить процесс обновления программного обеспечения и контента, а также обеспечить высокий уровень контроля за работой киосков в режиме реального времени.

Основные возможности: Программное средство предоставляет централизованное управление сетью киосков, позволяя администраторам контролировать их состояние, обновлять программное обеспечение и контент, управлять пользователями и их правами доступа. Система формирует аналитические отчёты и статистику работы киосков, что способствует оптимизации их использования. Кроме того, она обеспечивает автоматическую отправку уведомлений о неисправностях и сбоях, что позволяет быстро реагировать на проблемы. Решение отличается высокой надёжностью, безопасностью данных и возможностью масштабирования при увеличении количества устройств.

**Front:** [GitHub репозиторий](https://github.com/lizgorovaya/ADMFront)  
**Back:** [GitHub репозиторий](https://github.com/lizgorovaya/admin-panel)


## Содержание

1. [Архитектура](#архитектура)  
   i. [C4-модель](#c4-модель)  
   ii. [Схема данных](#схема-данных)  

2. [Функциональные возможности](#функциональные-возможности)  
   i. [Диаграмма вариантов использования](#диаграмма-вариантов-использования)  
   ii. [User-flow диаграммы](#user-flow-диаграммы)  

3. [Детали реализации](#детали-реализации)  
   i. [UML-диаграммы](#uml-диаграммы)  
   ii. [Спецификация API](#спецификация-api)  
   iii. [Безопасность](#безопасность)  
   iv. [Оценка качества кода](#оценка-качества-кода)
   v. [Документация](#документация)

5. [Тестирование](#тестирование)  
   i. [Unit-тесты](#unit-тесты)  
   ii. [Интеграционные тесты](#интеграционные-тесты)  

6. [Установка и запуск](#установка-и-запуск)  
   i. [Манифесты для сборки docker образов](#манифесты-для-сборки-docker-образов)  
   ii. [Манифесты для развертывания k8s кластера](#манифесты-для-развертывания-k8s-кластера)  

7. [Лицензия](#лицензия)  
8. [Контакты](#контакты)




## Архитектура

### C4-модель


Модель C4 важна при построении архитектуры программных систем, так как она позволяет наглядно и поэтапно описывать структуру проекта на разных уровнях абстракции. С её помощью можно показать, как система взаимодействует с внешними пользователями и другими системами, из каких контейнеров (приложений, сервисов, баз данных) она состоит, как устроены её внутренние компоненты и каким образом реализован код. На рисунке 1 представлена модель контейнерного уровня С4.

<img width="975" height="631" alt="image" src="https://github.com/user-attachments/assets/6cefd2be-f334-46b0-89e5-44ad8f36fdf5" />

Диаграмма описывает систему взаимодействия пользователей с программным средством администрирования инфокиосков, предназначенную для централизованного управления контентом, пользователями и аналитикой. Администратор Брестэнерго управляет системой и пользователями, контролирует работу контент-менеджеров и аналитиков, а также следит за состоянием инфокиосков через веб-сервис администрирования. Контент-менеджер редактирует и обновляет материалы, которые отображаются на инфокиосках, загружает новые данные и корректирует существующий контент. Аналитик просматривает отчёты и статистику использования инфокиосков, получая информацию о посещаемости, активности пользователей и эффективности контента через программное средство.    
Программное средство администрирования является центральным элементом системы, обеспечивая взаимодействие всех пользователей и получая контент от внешних систем, представленных тремя экземплярами инфокиосков. Пользователи работают с веб-сервисом, который, в свою очередь, интегрирован с инфокиосками для актуализации контента, а администратор обеспечивает корректную работу системы и управление ролями. Таким образом, система обеспечивает централизованное управление контентом, контроль доступа и ролей пользователей, получение и отображение аналитических данных и взаимодействие с внешними инфокиосками для поддержания актуальности информации.
Далее представлена компонентный уровень модели С4 для детального представления программного обеспечения внутри одного контейнера. Она показывает, как система организована из отдельных компонентов, какие у них обязанности, как они взаимодействуют друг с другом и с внешними системами. На рисунке 2 представлена модель компонентного уровня модели С4.

<img width="974" height="494" alt="image" src="https://github.com/user-attachments/assets/f055a10b-52f4-4876-843f-028092d4db88" />

В системе выделяется три типа пользователей. Администратор управляет системой и пользователями, назначает роли, контролирует корректность работы контент-менеджеров и аналитиков, а также мониторит работу инфокиосков. Контент-менеджер отвечает за подготовку и публикацию материалов: он редактирует текст, изображения и другие элементы контента, который затем отображается на инфокиосках. Аналитик получает доступ к отчётам и статистике, формируемой системой, что позволяет оценивать эффективность публикаций и активность пользователей. Все пользователи взаимодействуют с системой через веб-приложение, которое служит интерфейсом для выполнения всех задач: управления пользователями, публикации контента и просмотра аналитики.
Веб-приложение представляет собой фронтенд, построенный как клиентское веб-приложение, которое делает запросы к API-сервису. Оно обеспечивает удобный интерфейс и визуализацию данных для всех типов пользователей, управляет навигацией, формами редактирования и представлением отчётов.
API-сервис является центральным компонентом backend. Он обрабатывает запросы веб-приложения, управляет пользователями и ролями, хранит и обновляет контент, собирает и обрабатывает журналы посещений от инфокиосков. Кроме того, API-сервис реализует бизнес-логику и маршрутизацию данных между компонентами системы, обеспечивая целостность и согласованность информации.
База данных MySQL хранит всю основную информацию: сведения о пользователях, их ролях, опубликованном контенте и журналы посещений инфокиосков. Она служит основным источником данных для API-сервиса и модуля аналитики.
Инфокиоски подключаются к системе через API-сервис. Они получают актуальный контент для отображения и передают обратно журналы посещений и другую статистическую информацию. Это позволяет системе поддерживать контент в актуальном состоянии и собирать данные для анализа.
Модуль аналитики, встроенный в backend, обрабатывает журналы посещений, анализирует активность пользователей и эффективность контента, а затем формирует отчёты, доступные аналитикам через веб-приложение. Модуль позволяет оценивать работу инфокиосков, выявлять популярный контент и принимать управленческие решения.
Таким образом, система реализует полный цикл администрирования и анализа: пользователи через веб-приложение управляют контентом и ролями, API-сервис обеспечивает обработку данных и взаимодействие с базой, инфокиоски получают контент и передают статистику, а модуль аналитики формирует отчёты для оценки эффективности работы системы.

### Схема данных

<img width="974" height="480" alt="image" src="https://github.com/user-attachments/assets/0a2f34a2-251c-4c45-b1be-1e8f36a1da4f" />


Проектируемая база данных kiosk_admin соответствует требованиям третьей нормальной формы (3НФ), так как все таблицы содержат атрибуты, функционально зависящие только от своих первичных ключей, и не имеют транзитивных зависимостей между неключевыми полями. 
Таблица users. Таблица хранит информацию о пользователях системы. Каждый атрибут (username, password_hash, role, created_at) однозначно зависит от первичного ключа id. Между неключевыми атрибутами функциональных зависимостей нет – роль пользователя не зависит от его имени или даты создания записи. Следовательно, таблица users находится в 3НФ.
Таблица kiosks. Таблица содержит сведения о киосках, подключённых к системе. Все поля (name, location, ip_address, status, last_sync) зависят исключительно от ключа id. Поле status не зависит ни от имени, ни от IP-адреса, что исключает транзитивные зависимости. Таким образом, таблица kiosks удовлетворяет требованиям 3НФ.
Таблица content_types Таблица описывает типы контента (текст, изображение, видео). Атрибут name функционально зависит только от id, и так как других неключевых атрибутов нет, таблица полностью нормализована. content_types находится в 3НФ.
Таблица contents. Таблица хранит контент, размещаемый на киосках. Атрибуты (title, type_id, data_url, created_by, created_at, updated_at) полностью зависят от первичного ключа id. Поля type_id и created_by являются внешними ключами, которые обеспечивают связь с таблицами content_types и users, исключая дублирование данных. Зависимостей между неключевыми полями нет. Таблица находится в 3НФ.
Таблица deployments описывает размещение контента на киосках. Каждый атрибут (kiosk_id, content_id, deployed_at, status) зависит только от идентификатора развертывания id. Внешние ключи kiosk_id и content_id корректно связывают таблицу с киосками и контентом, обеспечивая целостность данных. Никаких транзитивных зависимостей между полями нет, следовательно, таблица соответствует 3НФ.
Таблица logs предназначена для хранения журналов событий, связанных с киосками. Поля (kiosk_id, level, message, created_at) функционально зависят от первичного ключа id. Поле kiosk_id является внешним ключом, связывающим запись лога с конкретным киоском. В таблице отсутствуют зависимости между неключевыми атрибутами, поэтому она также находится в 3НФ.


## Функциональные возможности

### Диаграмма вариантов использования

### User-flow диаграммы

Первый разработанный user-flow для роли – системный администратор.
Цель роли системный администратор обеспечивает безопасное и стабильное функционирование всей системы администрирования киосков. Он управляет правами доступа пользователей, контролирует действия сотрудников и следит за соблюдением политик безопасности. Роль позволяет централизованно управлять учетными записями, отслеживать все действия через журналы аудита, настраивать параметры безопасности, выполнять резервное копирование и восстановление данных. Основная цель – гарантировать, что доступ к системе имеют только уполномоченные пользователи и что вся информация надёжно защищена. Ниже описан основной путь следования системного администратора.
1 Администратор открывает страницу входа в систему и видит форму для авторизации. Он вводит логин и пароль, чтобы система могла идентифицировать его и проверить, что у него есть права администратора. Этот шаг необходим для защиты системы от несанкционированного доступа.
2 После ввода учетных данных система предлагает пройти двухфакторную аутентификацию или авторизацию через корпоративный SSO. Пользователь подтверждает свою личность с помощью кода из приложения или через корпоративный аккаунт. Это повышает безопасность и предотвращает доступ злоумышленников.
3 После успешной авторизации администратор попадает на главную панель. Здесь отображается обзор состояния системы: уведомления о действиях пользователей, последние изменения, ошибки, предупреждения, а также быстрые ссылки на основные модули.
4 Администратор выбирает модуль управления пользователями. Здесь он может создавать новых пользователей, задавать роли и права, редактировать информацию о существующих пользователях или удалять учетные записи, если они больше не нужны. Система обеспечивает контроль, чтобы изменения не повлияли на безопасность.
5 Если выбранный пользователь требует прав суперпользователя, администратор переходит в модуль настройки политик безопасности. Здесь он устанавливает ограничения доступа, проверяет полномочия и сохраняет изменения. После этого возвращается на главную панель.
6 Администратор может открыть журналы аудита, чтобы просмотреть историю действий пользователей: входы в систему, изменения данных, ошибки и подозрительные действия. При необходимости журналы можно экспортировать для анализа или отчёта.
7 Далее администратор может настроить параметры безопасности системы, включая политику паролей, ограничения доступа, двухфакторную аутентификацию и другие настройки, которые обеспечивают защиту данных.
8 При необходимости выполняется резервное копирование данных или восстановление из предыдущей копии, чтобы предотвратить потерю информации в случае сбоев или ошибок.
9 После завершения всех операций администратор выходит из системы, закрывая сеанс работы и обеспечивая безопасность системы.
Диаграмма User-flow для системного администратора представлена на рисунке 1.

<img width="974" height="767" alt="image" src="https://github.com/user-attachments/assets/fb2fd64c-c027-4bec-9075-970eae385430" />


Следующая роль, которая представлена в системе, администратор киосков. 
Цель роли: Администратор киосков отвечает за управление жизненным циклом всех устройств организации. Он добавляет новые киоски в систему, настраивает их параметры, редактирует существующие и удаляет ненужные устройства. Также он отслеживает состояние устройств, просматривает логи работы и формирует отчёты для анализа эффективности работы киосков. Основная цель роли – обеспечить корректную работу всех киосков, своевременное обновление программного обеспечения и контроль состояния устройств, чтобы пользователи и клиенты получали качественный и актуальный контент. Далее будет описан user flow для администратора киоска.
1 Администратор киосков открывает страницу входа и вводит логин и пароль для доступа к панели управления киосками.
2 После авторизации он попадает на обзорную панель, где отображаются все киоски организации с текущим состоянием: активные, оффлайн, с ошибками, с доступным или устаревшим контентом.
3 Пользователь может добавить новый киоск. Для этого открывается форма, где нужно указать название, местоположение, сетевые настройки, тип контента и другие параметры. После сохранения новый киоск появляется в общем списке и готов к работе.
4 Для существующих киосков администратор открывает форму редактирования и изменяет необходимые параметры: обновляет программное обеспечение, корректирует настройки отображения контента и сохраняет изменения.
5 Если киоск больше не нужен, администратор выбирает его и удаляет. Система запрашивает подтверждение, чтобы предотвратить случайное удаление, после чего киоск удаляется из системы.
6 Пользователь может просматривать текущее состояние киосков, проверять активность контента, сетевые подключения и логи работы устройств для диагностики проблем.
7 Администратор формирует отчёты по выбранным киоскам, включая данные о состоянии, ошибках, обновлениях и активности контента. Отчёты можно скачать для анализа и передачи руководству.
8 После завершения всех действий администратор выходит из системы, завершая сеанс работы.
Ниже представлена диаграмма user flow для системного администратора на рисунке 2.


<img width="974" height="339" alt="image" src="https://github.com/user-attachments/assets/a1a9a18c-c918-423f-9160-15042337f7b8" />


Следующая роль, которая представлена в системе, редактор контента. Цель роли: Редактор контента отвечает за подготовку, организацию и публикацию материалов на киосках. Он загружает новые файлы, редактирует метаданные, создаёт плейлисты и планирует публикации на определённых устройствах. Эта роль обеспечивает, что контент отображается корректно, вовремя и в нужных местах. Основная цель роли – гарантировать, что на киосках всегда актуальная и правильно организованная информация для конечных пользователей, а процесс публикации автоматизирован и управляем.
1 Редактор контента входит в систему, вводя свои учетные данные для доступа к панели управления контентом.
2 После авторизации он попадает на главную панель, где отображается текущий контент, расписание публикаций, доступные плейлисты и уведомления о новых материалах.
3 Пользователь открывает библиотеку контента и просматривает загруженные материалы. Контент отсортирован по категориям и типам, что позволяет быстро находить нужные материалы.
4 Редактор загружает новый контент: выбирает файлы, добавляет описание, категории, ключевые метаданные. После загрузки материалы становятся доступными для использования в плейлистах и публикации на киосках.
5 Далее пользователь создаёт плейлист, добавляя выбранные материалы. Плейлист сохраняется и становится доступным для планирования публикаций.
6 Для публикации контента редактор открывает планировщик, выбирает киоски, задаёт дату и время публикации и подтверждает отправку. Система автоматически распределяет контент на выбранные устройства.
7 После публикации редактор может выполнить предпросмотр, чтобы убедиться, что контент корректно отображается на киосках, все метаданные верны, а видео и изображения воспроизводятся правильно.
8 После завершения всех действий редактор выходит из системы, закрывая сеанс работы.
Далее представлена диаграмма user-flow на рисунке 3.

<img width="771" height="455" alt="image" src="https://github.com/user-attachments/assets/eb916750-24a7-4cdc-bd73-24ee89e1f3b2" />

Следующая роль, которая представлена в системе, техник. Цель роли:
Техник отвечает за обслуживание и диагностику киосков на местах или удалённо. Он проводит проверку состояния устройств, выявляет неисправности, выполняет удалённое управление, перезагрузку или собирает логи для анализа. Также техник планирует обновления программного обеспечения и фиксирует результаты своих действий в отчётах. Основная цель роли – обеспечить бесперебойную работу киосков и быстрое устранение технических проблем, минимизируя время простоя устройств.
Далее представлено описание user-flow. 
1 Техник входит в систему и попадает на панель с текущими заданиями и тикетами на обслуживание киосков.
2 Пользователь просматривает список заданий и выбирает киоск, который необходимо обслужить.
3 Техник запускает диагностику выбранного киоска с помощью удаленного мониторинга: проверяет состояние устройства, работоспособность контента, подключение к сети и ошибки системы.
4 В зависимости от результата диагностики:
Если киоск неисправен, техник выполняет необходимые действия: удалённое управление, перезагрузку устройства, сбор логов для последующего анализа.
Если киоск исправен, техник планирует обновление программного обеспечения для поддержания актуальности и безопасности.
5 После выполнения всех действий техник создаёт отчёт, в котором фиксирует состояние киоска, выполненные операции, выявленные ошибки и рекомендации.
6 Техник закрывает тикет и возвращается к списку заданий для выполнения следующих операций.
7 После выполнения всех задач техник выходит из системы, завершив рабочий сеанс.
Далее представлена диаграмма user-flow на рисунке 4.


<img width="479" height="654" alt="image" src="https://github.com/user-attachments/assets/780d4d30-3662-4746-9ca2-071a90dc016f" />


Следующая роль, которая представлена в системе, оператор поддержки.
Цель роли: Оператор поддержки отвечает за обработку инцидентов и обращений, связанных с работой киосков. Он просматривает очередь тикетов, выбирает конкретные инциденты для обработки, решает их самостоятельно или эскалирует к технику. Также оператор фиксирует результаты работы и формирует отчёты. Основная цель роли – поддерживать бесперебойную работу киосков, оперативно решать проблемы пользователей и обеспечивать корректную работу системы поддержки.
Далее представлено описание user-flow. 
1 Оператор поддержки входит в систему и попадает на панель с очередью инцидентов и тикетов.
2 Пользователь просматривает список инцидентов, сортируя их по приоритету, дате создания или типу проблемы.
3 Оператор выбирает конкретный инцидент для обработки.
4 В зависимости от характера проблемы оператор решает, нужна ли эскалация:
Если требуется вмешательство техника, он передаёт задачу и фиксирует информацию о передаче.
Если эскалация не требуется, выполняет автоматическое решение или перезапуск системы для устранения проблемы.
5 После решения инцидента оператор закрывает тикет и фиксирует результат обработки.
6 При необходимости формирует отчёты о работе с инцидентами, включая количество закрытых тикетов, причины обращений и результаты обработки.
7 Возвращается к очереди инцидентов для обработки новых задач.
8 После завершения всех действий оператор выходит из системы.
Далее представлена диаграмма user-flow на рисунке 5.

<img width="730" height="881" alt="image" src="https://github.com/user-attachments/assets/4a683b26-8ad6-424c-a3ea-d7a04dc05935" />


Следующая роль, которая представлена в системе, аналитик. Цель роли:
Аналитик отвечает за сбор, обработку и анализ данных о работе киосков и контента. Он формирует отчёты, строит визуализации и графики, чтобы оценить эффективность работы устройств, публикаций и активности пользователей. Также он планирует автоматическую генерацию отчётов для регулярного контроля. Основная цель роли – предоставить руководству и ответственным сотрудникам точную информацию для принятия решений, улучшения работы системы и оптимизации процессов управления контентом и устройствами.
1 Пользователь входит в систему и получает доступ к панели аналитики.
2 На панели аналитики отображается информация о состоянии всех киосков, активности контента, публикациях и ошибках.
3 Пользователь выбирает тип отчёта для анализа: отчёт по контенту, по состоянию киосков или по активности пользователей.
4 Отфильтровывает данные по критериям: временной период, конкретные киоски, категории контента и другие параметры.
5 Генерирует отчёт и просматривает визуализации, графики и диаграммы для анализа эффективности работы киосков.
6 При необходимости экспортирует отчёт в PDF или CSV, чтобы передать его руководству или использовать в презентации.
7 Планирует автоматическое формирование отчётов на регулярной основе, чтобы получать актуальные данные без ручного вмешательства.
8 После завершения всех операций пользователь выходит из системы, закрывая сеанс работы.
Далее представлена диаграмма user-flow на рисунке 6.

<img width="547" height="725" alt="image" src="https://github.com/user-attachments/assets/202abb6b-b6b9-466a-a8ff-9e8745082c60" />



## Детали реализации

# Распространённые ошибки при разработке на Laravel

Разработка на Laravel даёт множество встроенных инструментов для ускорения работы. Однако именно из-за этого программисты часто допускают ошибки, которые приводят к некачественному коду. Наиболее распространённые из них связаны с:  

- Перегрузкой контроллеров  
- Дублированием логики  
- Неправильной работой с базой данных  
- Отсутствием обработки ошибок  
- Нарушением архитектурных принципов  

Часто вся логика — от валидации входных данных и бизнес-правил до взаимодействия с базой и отправки уведомлений — пишется в одном методе. Такой код трудно поддерживать и тестировать.  

```php
public function store(Request $request)
{
    if (!$request->has('email')) {
        return response()->json(['error' => 'Email is required'], 400);
    }

    $user = new User();
    $user->name = $request->input('name');
    $user->email = $request->input('email');
    $user->save();

    Mail::to($user->email)->send(new WelcomeMail($user));

    return response()->json(['message' => 'User created']);
}

```

Исправление заключается в разделении ответственности. Валидацию стоит вынести в отдельный FormRequest, бизнес-логику – в сервисный слой, а отправку писем – в очередь.

```php
// Хороший код
public function store(CreateUserRequest $request, UserService $service)
{
    $user = $service->createUser($request->validated());
    return response()->json(['message' => 'User created']);
}

```

Не менее частой ошибкой является дублирование кода. В приложениях для администрирования киосков, например, активация и деактивация может повторяться в разных контроллерах.

```php
// Плохой код
$user->status = 'inactive';
$user->save();

$kiosk->status = 'inactive';
$kiosk->save();

```

Чтобы избежать повторов, стоит вынести логику в общий метод.

```php
// Хороший код
public function deactivate(Model $entity)
{
    $entity->status = 'inactive';
    $entity->save();
}

```

Серьёзной проблемой является неэффективная работа с базой данных. Одной из типичных ошибок считается загрузка всех записей через Model::all(), даже если нужно обработать миллионы строк.

```php
// Плохой код
$logs = LogEntry::all();
foreach ($logs as $log) {
    // обработка
}
```

Это приводит к утечке памяти. Более эффективный подход – использовать chunk:

```php
// Хороший код
LogEntry::chunk(500, function ($logs) {
    foreach ($logs as $log) {
        // обработка
    }
});

```

Другая проблема связана с так называемой ошибкой N+1 запросов. Она возникает, когда для каждой записи делается отдельный запрос к связанным данным.

```php
// Плохой код
$users = User::all();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Laravel при этом выполняет десятки дополнительных запросов. Исправление заключается в использовании жадной загрузки:

```php
// Хороший код
$users = User::with('profile')->get();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Проблемой можно назвать и отсутствие обработки ошибок. Например, попытка получить пользователя по ID без проверки может привести к фатальной ошибке:

```php
// Плохой код
$user = User::find($id);
return $user->email;
```

Гораздо лучше обрабатывать ситуации, когда объект не найден:

```php
// Хороший код
$user = User::find($id);
if (!$user) {
    return response()->json(['error' => 'User not found'], 404);
}
return $user->email;
```

Часто встречается и плохой нейминг функций и переменных. Код с названиями вроде doIt($a, $b) непонятен даже автору спустя время.

```php
// Плохой код
function doIt($a, $b) {
    return $a + $b;
}
```

Хорошее название делает код самодокументируемым:

```php
// Хороший код
function calculateInvoiceTotal($subtotal, $tax) {
    return $subtotal + $tax;
}
```

Ещё одна распространённая ошибка – использование временных переменных, которые не добавляют смысла.

```php
// Плохой код
$tmp = $request->input('location');
$kiosk->location = $tmp;
```

Запись можно упростить:

```php
// Хороший код
$kiosk->location = $request->input('location');

Отдельно стоит выделить захардкоденные значения в коде. Например:

```php
// Плохой код
if ($user->role === 'admin') {
    // особая логика
}
```

Лучше использовать константы или конфиги:

```php
// Хороший код
if ($user->role === User::ROLE_ADMIN) {
    // особая логика
}
```

# Распространённые проблемы и ошибки при разработке на Angular

Во фронтенд-разработке на Angular можно встретить похожие по сути проблемы, что и в Laravel, но проявляются они по-своему. Основная из них связана с перегруженными компонентами.  

Разработчики часто помещают и бизнес-логику, и работу с API, и управление состоянием прямо в компонент. Такой подход затрудняет сопровождение и тестирование.  

---

```typescript
/Плохой пример
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users: any[] = [];
  constructor(private http: HttpClient) {
    this.http.get<any[]>('/api/users').subscribe(data => {
      this.users = data.filter(u => u.active);
    });
  }
}
```

Лучшим решением является вынесение логики работы с данными в отдельный сервис, а компонент должен только подписываться на поток данных.

```typescript
// Хороший код (разделение обязанностей)
@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}
  getActiveUsers() {
    return this.http.get<User[]>('/api/users')
      .pipe(map(users => users.filter(u => u.active)));
  }
}
```
```typescript
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users$ = this.userService.getActiveUsers();
  constructor(private userService: UserService) {}
}
```

Другая распространённая ошибка связана с утечками памяти из-за отсутствия отписки от подписок. Когда в компоненте используется subscribe, но отписка в ngOnDestroy не реализована, память продолжает удерживать подписки даже после удаления компонента.

```typescript
// Плохой код (подписка без отписки)
ngOnInit() {
  this.http.get('/api/data').subscribe(result => {
    this.data = result;
  });
}
```

Исправлением является либо явная отписка с помощью Subject и takeUntil, либо использование async pipe, который сам управляет подпиской.

```typescript
// Хороший код (async pipe)
data$ = this.http.get('/api/data');
<div *ngIf="data$ | async as data">
  {{ data }}
</div>
```

Часто встречается и проблема слишком сложной логики прямо в шаблонах. Например:

```typescript
<!-- Плохой код -->
<div>{{ users.filter(u => u.active).map(u => u.name).join(', ') }}</div>
```

Каждый цикл изменения состояния Angular будет заново выполнять фильтрацию и объединение строк, что негативно сказывается на производительности. Логичнее вынести подготовку данных в компонент:

```typescript
// Хороший код
activeUserNames = '';
ngOnInit() {
  this.userService.getActiveUsers().subscribe(users => {
    this.activeUserNames = users.map(u => u.name).join(', ');
  });
}

<div>{{ activeUserNames }}</div>

```

Неудачные имена переменных и методов также характерны для Angular. Код с переменными вроде d, arr, tmp становится нечитаемым:

```typescript
// Плохой код
let d = this.http.get('/api/kiosks');

```

Понятные названия делают код самодокументируемым:

```typescript
let kiosks$ = this.http.get<Kiosk[]>('/api/kiosks');
```

В Angular иногда встречается и чрезмерное использование any, что убивает преимущества TypeScript.

```typescript
// Плохой код
users: any[] = [];
```

Гораздо правильнее использовать строгую типизацию:

```typescript
// Хороший код
users: User[] = [];
```

Оптимизационные ошибки также играют важную роль. Например, использование *ngFor без ключа trackBy при больших списках приводит к тому, что Angular каждый раз пересоздаёт все элементы при малейшем изменении.

```typescript
<!-- Плохой код -->
<li *ngFor="let user of users">{{ user.name }}</li>
```

Гораздо лучше использовать trackBy, чтобы Angular понимал, какие элементы изменились, а какие остались прежними.

```typescript
<!-- Хороший код -->
<li *ngFor="let user of users; trackBy: trackById">{{ user.name }}</li>

trackById(index: number, item: User) {
  return item.id;
}
```

Неоптимальная работа с состоянием приложения также относится к типичным проблемам. Хранение сложных состояний прямо в компонентах затрудняет развитие кода. Лучшим решением является использование централизованного управления состоянием (NgRx или аналогичных решений).










### UML-диаграммы


В ходе разработки программного средства для администрирования распределённых информационных киосков организации были созданы несколько UML-диаграмм, отражающих как статическую, так и динамическую структуру проектируемой системы.
Каждая диаграмма выполняет свою роль в моделировании архитектуры и логики функционирования программного комплекса.
Первой разработанной диаграммой, описание которой представлено ниже. Диаграмма вариантов использования относится к динамическим диаграммам, так как описывает поведение системы с точки зрения взаимодействия внешних акторов с системой. На ней представлены основные пользователи – администратор и информационный киоск – а также совокупность прецедентов, реализующих ключевые функции: авторизация, управление киосками, редактирование и обновление контента, мониторинг состояния устройств, резервное копирование и формирование отчётов.
Данная диаграмма отражает границы системы и описывает, какие функции доступны пользователям и как они связаны между собой через отношения include и extend.

<img width="974" height="667" alt="image" src="https://github.com/user-attachments/assets/ab407368-b379-4bac-914d-cc5f95654b42" />

Данная диаграмма демонстрирует взаимодействие двух основных акторов – администратора и киоска – с системой, а также показывает взаимосвязь между различными вариантами использования, включающими операции управления, обновления, мониторинга и обмена данными.
Центральной фигурой является администратор, который взаимодействует с системой через веб-интерфейс, выполняя административные функции. Диаграмма показывает, что его работа начинается с процесса авторизации в системе, который выступает базовым действием и включается во все остальные сценарии, требующие проверки прав доступа. Авторизация является обязательной предусловием для любых операций изменения или мониторинга, что подчёркивает безопасность системы. После успешного входа администратор получает возможность просматривать список киосков, мониторить сеть, редактировать данные устройств, управлять контентом и расписаниями обновлений, а также работать с отчётами.
Далее, диаграмма показывает логику взаимодействий между действиями. Операция добавления нового киоска включает прецедент регистрации киоска в системе, что означает создание новой записи об устройстве, привязку к сети и настройку базовых параметров для последующей работы. Аналогично, удаление киоска расширяет прецедент просмотра списка – то есть выполняется из того же интерфейса, когда администратор уже видит текущее состояние устройств.
Функциональность, связанная с поддержанием и обновлением контента, представлена группой взаимосвязанных прецедентов, объединённых логикой управления контентом. Администратор может загрузить новый контент, обновить существующий, удалить устаревший и инициировать развёртывание контента на киосках. Развёртывание связано как с действием администратора, так и с самим киоском: после отправки задачи устройства принимают пакет обновления, проверяют корректность файлов и выполняют установку. Если во время обновления возникает сбой, активируется дополнительный прецедент отправки уведомления об ошибке, что расширяет сценарий развёртывания. Таким образом, система поддерживает механизм автоматического уведомления и контроля корректности операций.
Отдельная логическая ветвь на диаграмме связана с мониторингом сети киосков. Этот вариант использования подразумевает сбор системных данных о состоянии устройств, уровне их доступности и успешности обновлений. Прецедент мониторинга включает в себя получение отчётов от киосков, представленных в диаграмме как прецедент отправки отчёта о состоянии. Это действие инициируется киосками автоматически, без участия администратора, и служит для обновления информации о текущем состоянии оборудования. Если отчёты содержат данные о неудачных обновлениях или сбоях, система может активировать расширяющий прецедент отправки уведомления об ошибке.
Также предусмотрен функционал просмотра логов и отчётов, который расширяет возможности мониторинга и позволяет администратору анализировать историю действий и результаты операций. Через эту часть системы администратор может видеть последовательность установок контента, ошибки и время выполнения задач, что важно для контроля и диагностики.
Управление пользователями включено в диаграмму как отдельный прецедент, однако он логически связан с авторизацией. Это означает, что только пользователь с соответствующими правами может добавлять или редактировать учётные записи других администраторов. Этот элемент подчёркивает безопасность и разграничение прав доступа внутри системы.
На стороне киоска отображены три ключевых варианта использования: передача отчётов, выполнение обновлений и отправка уведомлений об ошибке. Эти действия выполняются автоматически при взаимодействии устройства с сервером. Киоск получает команды от системы, загружает необходимые пакеты контента, применяет обновления и после завершения отправляет отчёт с результатами. Если установка завершается сбоем, автоматически формируется уведомление об ошибке, которое поступает на сервер администратора. Такое разделение ролей демонстрирует, что киоск не является пассивным элементом, а активно участвует в процессе обмена данными и поддерживает обратную связь с системой.
На диаграмме чётко обозначены связи include и extend, которые отражают внутреннюю логику процессов. Связи include указывают на обязательность выполнения подэтапов – например, регистрация киоска входит в добавление нового устройства, а авторизация является частью любой административной операции. Связи extend обозначают условные или дополнительные действия, которые выполняются при определённых обстоятельствах, например, удаление киоска расширяет просмотр списка, а уведомление об ошибке расширяет развёртывание контента. Это позволяет показать, какие процессы выполняются всегда, а какие активируются только при возникновении исключительных ситуаций.
Таким образом, диаграмма вариантов использования отражает полную картину взаимодействия между пользователем и системой. Она демонстрирует, что основная цель программного средства заключается в централизованном управлении сетью информационных киосков – от регистрации и обновления устройств до мониторинга их состояния и анализа отчётности. Диаграмма показывает баланс между автоматическими процессами (на стороне киосков) и действиями администратора, а также подчёркивает важность контроля, прозрачности и безопасности всех операций.
Далее нужно описать диаграмму классов данная диаграмма классов представляет собой детализированную модель структуры программного средства для администрирования распределённых информационных киосков организации. Она отражает все основные сущности системы, их атрибуты, методы и взаимосвязи, демонстрируя логику работы приложения и распределение ответственности между компонентами. Основная идея диаграммы заключается в том, чтобы показать, как административная часть системы взаимодействует с сетью физических киосков, обеспечивая централизованное управление контентом, мониторинг состояния устройств и обработку возникающих событий. 


<img width="974" height="939" alt="image" src="https://github.com/user-attachments/assets/a326a919-517c-431b-91f0-01747dde96af" />


В центре системы находится класс AdminUser, который представляет администратора, управляющего всей сетью киосков. Этот класс содержит основные атрибуты, такие как идентификатор пользователя, имя, хэш пароля, адрес электронной почты и роль, определяющую уровень доступа. Методы класса, включая login(), logout(), createKiosk(), assignContent() и viewLogs(), отражают типичные действия администратора – авторизацию, создание и настройку киосков, назначение контента для отображения, а также просмотр логов работы системы. Именно через этот класс реализуется контроль над инфраструктурой киосков, что обуславливает его прямые связи с несколькими другими классами. Связь между AdminUser и Kiosk показывает, что один администратор может управлять множеством киосков, добавляя новые устройства, редактируя их параметры или удаляя устаревшие. Аналогично, связь между AdminUser и Content отражает право администратора добавлять и редактировать мультимедийные материалы, которые впоследствии будут транслироваться на экранах киосков. Также администратор связан с классами DeploymentTask и Schedule, что подчёркивает его полномочия по созданию задач обновления контента и планированию этих операций во времени.
Класс Kiosk представляет собой программно-аппаратный терминал, размещённый на объекте организации. Он содержит конкретные характеристики, включая идентификатор, название, местоположение, IP-адрес, текущий статус и время последнего выхода в сеть. Методы receiveContent(), sendReport() и sendError() показывают, что киоск способен принимать контент, передавать отчёты о своём состоянии и отправлять уведомления об ошибках. Связь между Kiosk и KioskStatus реализуется через перечисление, фиксирующее возможные состояния устройства: активный, оффлайн, с ошибкой или в режиме обслуживания. Это позволяет системе отслеживать техническое состояние каждого киоска и своевременно реагировать на проблемы. Киоски могут быть объединены в логические группы, что отражено через связь с классом KioskGroup. Такая группировка упрощает массовое управление, например, когда администратор назначает одинаковый контент всем киоскам определённого подразделения.
Класс Content описывает объекты мультимедийного контента, который отображается на экранах киосков. Он включает поля, такие как идентификатор, заголовок, тип, версия, путь к файлу, дата загрузки и размер. Методы upload(), updateVersion() и delete() обеспечивают полный жизненный цикл контента от загрузки до удаления. Связь между Content и DeploymentTask указывает, что каждая задача развёртывания связана с конкретным контентом, который необходимо доставить на киоски. Таким образом, DeploymentTask становится связующим звеном между контентом и группами устройств.
Класс DeploymentTask представляет собой задачу на выполнение определённых действий, например, обновление контента или конфигурации на группе киосков. Он содержит атрибуты, описывающие идентификатор, время создания, статус выполнения и результат. Методы execute(), rollback() и checkStatus() позволяют управлять процессом выполнения и отслеживать его текущее состояние. Связь с перечислением TaskStatus даёт системе возможность фиксировать, на каком этапе находится задача – в ожидании, выполняется, завершена или завершилась ошибкой. Ассоциация между DeploymentTask и KioskGroup объясняется тем, что одна задача может выполняться одновременно на множестве киосков, принадлежащих одной или нескольким группам. Связь с классом Schedule показывает, что выполнение задач может быть автоматизировано с помощью планировщика, который запускает их в заранее определённое время.
Класс Schedule отвечает за планирование периодических операций в системе. Он содержит атрибуты с выражением CRON, указывающим расписание, флаг активности и время следующего запуска. Через методы planTask() и disable() администратор может включать и отключать автоматические задачи. Эта связь с DeploymentTask показывает, что расписание создаёт и контролирует выполнение определённых действий по обновлению контента.
Система также предусматривает сбор информации о состоянии киосков. Класс Report используется для формирования отчётов, которые киоск отправляет на сервер. Он включает данные об идентификаторе устройства, времени формирования, времени бесперебойной работы, количестве ошибок и текстовых деталях. Метод generateSummary() агрегирует информацию, создавая краткий отчёт для администратора. Параллельно работает класс LogRecord, который сохраняет внутренние события системы, включая время, уровень логирования, сообщение и источник. Эти данные используются для аудита и диагностики.
Класс ErrorNotification отражает механизм уведомления об ошибках. Каждый киоск при возникновении неисправности создаёт объект этого типа и отправляет его администратору. В нём фиксируются идентификатор киоска, временная метка, код ошибки и описание. Метод sendToAdmin() моделирует передачу уведомления в административную панель или по электронной почте.
Класс SystemSettings хранит параметры конфигурации всей системы. Его поля включают название параметра и значение, а метод updateSetting() обеспечивает изменение конфигурации без перезапуска приложения. Связь между SystemSettings и Kiosk отражает то, что каждая настройка может влиять на поведение нескольких киосков, например, изменять частоту обновления или формат отчётов.
Таким образом, диаграмма демонстрирует чёткую архитектуру распределённой системы, где AdminUser выступает управляющим центром, а Kiosk – периферийным узлом, взаимодействующим через задачи, отчёты и уведомления. Content, DeploymentTask и Schedule образуют функциональный цикл обновления контента, обеспечивая актуальность информации на киосках. KioskGroup упрощает масштабное администрирование, LogRecord, Report и ErrorNotification отвечают за мониторинг и обратную связь, а SystemSettings обеспечивает гибкую настройку. Такая структура обеспечивает расширяемость, надёжность и прозрачность управления, что делает её оптимальной для программного средства администрирования распределённых информационных киосков.
Диаграмма деятельности относится к динамическим UML-диаграммам, поскольку описывает последовательность действий и поток управления при выполнении бизнес-процессов системы. Она отражает этапы процесса обновления контента на киосках: от подготовки пакета контента и определения целевых устройств до проверки ресурсов, установки, контроля контрольной суммы и регистрации события аудита.
Данная диаграмма позволяет визуализировать логику работы системы и распределение ответственности между участниками процесса – администратором, сервером и самим киоском. 


<img width="2056" height="4041" alt="Диаграмма деятельности 3 лаба риопк drawio" src="https://github.com/user-attachments/assets/aec2f6c4-9298-45aa-968a-4227b44f92e9" />

Процесс начинается с того, что администратор открывает веб-панель и пытается войти в систему; если аутентификация успешна, интерфейс загружает список доступных киосков и последние отчёты, если нет – система возвращает ошибку и просит повторить вход или восстановить пароль. После успешного входа администратор выбирает цель – либо подготовить новый пакет контента для загрузки, либо выбрать уже существующий пакет и задать параметры развёртывания; при подготовке пакета администратор прикрепляет файлы, задаёт метаданные (версия, категория, критичность) и, при необходимости, указывает группу киосков или конкретные устройства. Как только пакет сформирован, администратор выбирает режим – немедленное развёртывание или создание расписания; при выборе расписания система запрашивает выражение CRON и сохраняет задание в планировщик. Если развёртывание назначено немедленно или запущено планировщиком, сервер выполняет предварительную валидацию пакета: проверяет целостность файлов (контрольные суммы), соответствие форматов и доступность файлового хранилища; в случае ошибки валидации процесс останавливается и администратор получает уведомление с описанием проблемы, при успешной валидации сервер регистрирует задачу развёртывания и помещает её в очередь задач. Следующим шагом сервер вычисляет таргет-список устройств и для каждого устройства проверяет текущее состояние: если киоск находится офлайн, система помечает устройство как отложенное и отправляет уведомление администратору о частичной недостижимости; если киоск онлайн, сервер отправляет команду на начало загрузки пакета вместе с адресом хранения и контрольной суммой. На стороне киоска агент получает команду, инициирует загрузку и параллельно может выполнять проверку доступного места и запущенных процессов; при нехватке ресурсов киоск возвращает подробный код ошибки и лог, после чего сервер помечает задачу для этого киоска как «failed» и, в зависимости от настроек задачи, либо инициирует попытку ретрая, либо оповещает администратора. Если скачивание прошло успешно, киоск выполняет проверку контрольной суммы, распаковку и установку контента; в момент установки киоск переключает локальные сервисы в режим обновления, чтобы избежать отображения неконсистентного контента. По завершении установки киоск формирует отчёт с результатом (success/failure), временем операции и сопутствующими логами и отправляет его на сервер. Сервер агрегирует ответы от всех целевых устройств, обновляет статус DeploymentTask (RUNNING → COMPLETED, или RUNNING → PARTIAL_FAILED/FAILED), сохраняет логи в центральное хранилище и, при обнаружении ошибок, запускает компенсирующие действия: по конфигурации это может быть автоматический rollback до предыдущей версии на поражённых киосках или создание уведомления/тикета для ручной проверки. Администратор получает итоговую сводку по задаче с возможностью просмотреть детальные логи по каждому киоску, инициировать повторный запуск задачи для неудачных устройств, сформировать поддержку и пометить киоск для физической проверки. В параллельной ветви системы работают мониторинг и уведомления: NetworkMonitor периодически пингует устройства и генерирует ErrorNotification при длительной недоступности, отчёты от киосков периодически попадают в систему и обновляют дашборд мониторинга, а AuditEvent фиксирует все критические операции администратора (создание задач, откаты, изменение расписаний) для последующего аудита. В завершение администратор может вручную убедиться в консистентности контента, скорректировать настройки SystemSettings или запустить BackupTask для сохранения текущей конфигурации и метаданных, после чего процесс считается завершённым; при этом любые незавершённые или отложенные задачи остаются в очереди и обрабатываются согласно политике ретраев или расписанию.
Диаграмма состояний также относится к динамическим диаграммам UML, так как описывает жизненный цикл объекта и его переходы между состояниями в зависимости от событий. В качестве основного объекта моделирования выбран информационный киоск, поведение которого изменяется в зависимости от взаимодействия с сервером и выполнения внутренних процессов.
Диаграмма отображает такие состояния, как «Ожидание подключения», «Активен», «Оффлайн», «Ожидание пакета», «Установка пакета», «Ошибка установки», «Резервное копирование» и «Неактивен».
Каждый переход между состояниями инициируется определённым событием – например, командой администратора, завершением установки или возникновением ошибки.

<img width="820" height="830" alt="image" src="https://github.com/user-attachments/assets/24d17942-68d7-470f-824e-1c4731bb458e" />


### Спецификация API

### Безопасность

В ходе работы была реализована полноценная система аутентификации и авторизации пользователей программной системы на основе Laravel (backend) и Vue.js (frontend). Целью реализации было обеспечение безопасного доступа пользователей к функционалу системы, разграничение прав и защита передаваемых данных.
На стороне сервера аутентификация реализована с использованием фреймворка Laravel Sanctum, который предоставляет лёгкий механизм для выдачи и проверки персональных токенов доступа. В процессе регистрации пользователь создаёт учётную запись, данные которой сохраняются в базе данных. Для безопасного хранения паролей используется встроенный механизм Laravel – хэширование через bcrypt, что исключает возможность хранения паролей в открытом виде. При входе пользователь передаёт email и пароль, которые сверяются с записями в базе. После успешной проверки создаётся токен авторизации, который возвращается клиенту. Этот токен сохраняется в localStorage на фронтенде и прикрепляется к каждому последующему запросу в виде заголовка Authorization: Bearer <token>.
Для выхода из системы реализован специальный маршрут /logout, который аннулирует токен пользователя, делая дальнейшее использование его недействительным. Таким образом, обеспечивается контроль за активными сессиями и предотвращается несанкционированный доступ после выхода.
На фронтенде с помощью Pinia создано хранилище auth.js, в котором сохраняются данные о текущем пользователе и токене. При авторизации состояние обновляется, а компонент интерфейса реагирует на это изменением кнопки –  после успешного входа надпись «Войти» меняется на “Выйти”. При нажатии на кнопку «Выйти» вызывается метод logout, который очищает токен, удаляет пользователя из состояния и сбрасывает заголовки Authorization.
Для защиты маршрутов на клиенте используется проверка авторизации: если пользователь не вошёл в систему, он не может получить доступ к закрытым страницам. Это реализовано как через Pinia-геттер isAuthenticated, так и через роутер Vue, который перенаправляет неавторизованных пользователей на страницу входа.
В процессе реализации были внесены изменения в архитектуру проекта: добавлены маршруты /login, /register, /logout и /user в Laravel, а также соответствующие компоненты во фронтенде. Были добавлены формы регистрации и входа, обработка ошибок при неверных данных и динамическое обновление интерфейса в зависимости от состояния пользователя.
Механизмы обеспечения безопасности включают в себя использование HTTPS (при деплое), защиту CSRF-токенами (по умолчанию в Laravel), хэширование паролей, а также разграничение прав доступа через middleware auth:sanctum. Все запросы, требующие авторизации, доступны только при наличии действительного токена. Это гарантирует, что только авторизованные пользователи могут выполнять определённые действия –  например, управлять своими данными или получать доступ к защищённым ресурсам.



### Оценка качества кода

В ходе анализа качества разработанного серверного приложения для управления киосками было установлено, что использование многослойной архитектуры Laravel позволило сформировать чёткую структуру проекта и обеспечить высокую модульность его компонентов. Разделение логики между контроллерами, сервисными классами и слоями работы с данными сделало систему понятной, легко расширяемой и удобной в сопровождении. Напри-мер, такие компоненты, как KioskController, KioskLogController и KioskVersionController, были сконструированы таким образом, что каждый из них несёт строго определённую ответственность – управление состоянием ки-осков, обработку логов и работу с версиями приложения соответственно. В свою очередь, логика обработки данных и взаимодействия с моделями была вынесена в соответствующие сервисы, что обеспечило компактность методов контроллеров и упрощение тестирования отдельных функциональных блоков.
При оценке качества кода особое внимание уделялось снижению шаб-лонных конструкций и повышению читаемости. Использование встроенных механизмов Laravel и строгого разграничения ролей между слоями позволило минимизировать объём дублирующегося кода. Структурирование логики внутри сервисов и корректное разделение обязанностей привели к снижению цикломатической сложности методов: большинство функций в таких серви-сах, как, например, логика подготовки данных для киосков, обработки heartbeat-запросов или записи диагностических сообщений, оставались про-стыми и линейными по структуре. Это способствовало улучшению сопро-вождаемости, поскольку методы стали короче, логичнее и легче поддавались модульному тестированию.
Дополнительным результатом применения многослойной архитектуры стало повышение устойчивости приложения к изменениям. Чёткая изоляция логики внутри сервисного уровня позволяет добавлять новые функции – например, расширение функционала KioskVersionController для управления обновлениями или улучшение механизма сбора логов в KioskLogController – без необходимости модификации существующих контроллеров или маршру-тов. Такой подход снижает риск регрессий и делает проект удобным для дол-госрочного развития.
Проведённая оценка производительности показала, что разработанное приложение стабильно обрабатывает запросы от киосков и административной панели. Среднее время отклика методов контроллеров, таких как отправка heartbeat-сигналов, получение конфигурации и загрузка логов, находится в пределах 100-200 миллисекунд, что обеспечивает предсказуемое поведение системы под нагрузкой. Дополнительные измерения показали, что приложе-ние запускается быстро и без существенных задержек, что важно при работе с Docker-контейнерами и при автоматическом развёртывании.
В целом проект соответствует современным требованиям к качеству серверных приложений. Использование контроллеров KioskController, KioskLogController и KioskVersionController совместно с сервисным слоем позволило достичь высокой читаемости, поддерживаемости и масштабируе-мости кода. Архитектура приложения обеспечивает низкую когнитивную нагрузку для разработчика, быстрый отклик API и устойчивость к будущим изменениям, что делает систему надёжным и расширяемым решением для управления сетью сенсорных киосков.


### Документация
Ссылка на файл с документацией для Postman: https://github.com/lizgorovaya/AdministrationSystem1/blob/main/ADMIN-PANEl.postman_collection.json


## Тестирование

### Unit-тесты

. Модульное тестирование (unit testing) – это процесс проверки отдельных компонентов или модулей программы на корректность работы. Основная цель модульного тестирования – убедиться, что каждая отдельная часть кода выполняет свои функции правильно, независимо от других частей системы. Модули могут быть отдельными функциями, методами или классами, и те-стируются они в изоляции от остального приложения.
Процесс модульного тестирования обычно начинается с определения функционала модуля и возможных сценариев его работы. Разрабатываются тест-кейсы, которые включают набор входных данных и ожидаемый резуль-тат работы модуля. Тесты должны покрывать все логические ветки кода, включая как стандартные ситуации, так и граничные или исключительные случаи. Это помогает выявить ошибки на раннем этапе разработки, когда их исправление проще и дешевле. Ниже представлен листинг модульного тест класса KioskLogsService.php.
```php
<?php

namespace Tests\Unit;

use App\Services\KioskLogService;
use App\Models\KioskLog;
use Tests\TestCase;
use Mockery;

class KioskLogServiceTest extends TestCase
{
    public function test_save_logs()
    {
        $repo = Mockery::mock(KioskLog::class);

        $repo->shouldReceive('insert')->once()->andReturn(true);

        $service = new KioskLogService($repo);

        $result = $service->saveLogs(1, [
            ['level' => 'info', 'message' => 'test']
        ]);

        $this->assertTrue($result);
    }
}
```

Для класса KioskServiceTest.php

```php
<?php

namespace Tests\Unit;

use App\Services\KioskService;
use App\Models\Kiosk;
use Tests\TestCase;
use Mockery;

class KioskServiceTest extends TestCase
{
    public function test_create_kiosk()
    {
        $repo = Mockery::mock(Kiosk::class);
        $repo->shouldReceive('create')->once()->andReturn([
            'id' => 1,
            'serial_number' => 'ABC123'
        ]);

        $service = new KioskService($repo);

        $result = $service->create([
            'serial_number' => 'ABC123'
        ]);

        $this->assertEquals(1, $result['id']);
        $this->assertEquals('ABC123', $result['serial_number']);
    }

    public function test_get_kiosk()
    {
        $repo = Mockery::mock(Kiosk::class);
        $repo->shouldReceive('find')->with(1)->andReturn([
            'id' => 1,
            'serial_number' => 'XYZ'
        ]);

        $service = new KioskService($repo);
        $result = $service->getById(1);

        $this->assertEquals('XYZ', $result['serial_number']);
    }
}
```

Для класса KioskVersionServiceTest.php

```php

<?php

namespace Tests\Unit;

use App\Services\KioskVersionService;
use App\Models\AppVersion;
use Tests\TestCase;
use Mockery;

class KioskVersionServiceTest extends TestCase
{
    public function test_get_latest_version()
    {
        $repo = Mockery::mock(AppVersion::class);
        $repo->shouldReceive('latest->first')->andReturn([
            'version' => '2.0.0'
        ]);

        $service = new KioskVersionService($repo);
        $result = $service->getLatest();

        $this->assertEquals('2.0.0', $result['version']);
    }
}
```

Для класса KioskConfigServiceTest.php

```php

<?php

namespace Tests\Unit;

use App\Services\KioskConfigService;
use App\Models\KioskConfig;
use Tests\TestCase;
use Mockery;

class KioskConfigServiceTest extends TestCase
{
    public function test_get_config()
    {
        $repo = Mockery::mock(KioskConfig::class);

        $repo->shouldReceive('where->first')->andReturn([
            'config' => ['theme' => 'dark'],
            'updated_at' => now()
        ]);

        $service = new KioskConfigService($repo);
        $result = $service->getConfig(10);

        $this->assertEquals('dark', $result['config']['theme']);
    }
}
```


	Все модульные тесты были успешно выполнены, и их результаты под-твердили корректную работу проверяемых компонентов. Каждый тест прове-рял отдельную функцию или метод в изоляции, обеспечивая уверенность в том, что изменения в коде не нарушают существующую функциональность. Ошибок и сбоев при выполнении тестов не выявлено, что позволяет считать систему стабильной на уровне модульного тестирования.


### Интеграционные тесты

Интеграционное тестирование направлено на проверку взаимодействия раз-личных модулей и компонентов системы в целом. В отличие от модульного тестирования, которое проверяет отдельные функции или классы в изоляции, интеграционные тесты оценивают, как компоненты работают вместе, коррект-но ли передаются данные между слоями и правильно ли обрабатываются за-просы. Это позволяет выявить ошибки на стыке модулей, которые невозмож-но обнаружить при одиночном тестировании функций.
В процессе интеграционного тестирования часто используются реаль-ные версии баз данных, сервисов и внешних API. Это помогает моделировать реальные сценарии использования приложения и проверять его поведение в условиях, максимально приближенных к рабочей среде. Тесты могут вклю-чать проверки контроллеров, сервисов, репозиториев и других компонентов, гарантируя, что система как единое целое функционирует корректно. Ниже представлен листинг интеграционных тестов.

```php
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class KioskLogTest extends TestCase
{
    use RefreshDatabase;

    public function test_kiosk_can_send_logs()
    {
        $token = $this->kioskToken();

        $payload = [
            'logs' => [
                ['level' => 'info', 'message' => 'System OK'],
                ['level' => 'error', 'message' => 'Camera offline']
            ]
        ];

        $response = $this->postJson('/api/kiosk/logs', $payload, [
            'Authorization' => "Bearer {$token}"
        ]);

        $response->assertStatus(201)
            ->assertJson([
                'saved' => true
            ]);
    }
}

<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class KioskRegistrationTest extends TestCase
{
    use RefreshDatabase;

    public function test_kiosk_can_register()
    {
        $payload = [
            'serial_number' => 'KIOSK-100',
            'location' => 'Main Hall',
            'app_version' => '1.0.0'
        ];

        $response = $this->postJson('/api/kiosk/register', $payload);

        $response->assertStatus(201)
            ->assertJsonStructure([
                'id',
                'serial_number',
                'token'
            ]);
    }
}

<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;
use App\Models\KioskConfig;

class KioskConfigTest extends TestCase
{
    use RefreshDatabase;

    public function test_kiosk_can_get_config()
    {
        $token = $this->kioskToken();

        // Предсоздаём конфигурацию
        KioskConfig::factory()->create([
            'kiosk_id' => 1,
            'config' => ['theme' => 'dark']
        ]);

        $response = $this->getJson('/api/kiosk/config', [
            'Authorization' => "Bearer {$token}"
        ]);

        $response->assertStatus(200)
            ->assertJsonStructure([
                'config',
                'updated_at'
            ])
            ->assertJsonPath('config.theme', 'dark');
    }
}

<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class KioskHeartbeatTest extends TestCase
{
    use RefreshDatabase;

    public function test_kiosk_can_send_heartbeat()
    {
        $token = $this->kioskToken();

        $response = $this->postJson('/api/kiosk/heartbeat', [], [
            'Authorization' => "Bearer {$token}"
        ]);

        $response->assertStatus(200)
            ->assertJson([
                'status' => 'ok'
            ]);
    }
}
```

Все интеграционные тесты были выполнены корректно: каждый сцена-рий, включая взаимодействие контроллеров, сервисов и репозиториев, про-шёл успешно, а ожидаемые результаты совпали с фактическими. Это под-тверждает стабильность и корректность работы системы на уровне интегра-ции всех модулей.


## Установка и запуск

### Манифесты для сборки docker образов

Для развертывания программной системы была выбрана технология контейнеризации Docker, так как она обеспечивает изоляцию окружения, предсказуемость выполнения и полную воспроизводимость сборки на любой машине. Использование Docker позволяет гарантировать одинаковую работу фронтенд- и backend-части проекта независимо от операционной системы, установленного ПО, версии PHP, Node.js или MySQL. Контейнеризация исключает типичные проблемы несовместимости окружений, поскольку весь стек – от интерпретатора до зависимостей и серверных служб – упакован в образы и запускается в виде контейнеров.
Кроме того, Docker позволяет исключить ручную установку MySQL, PHP, Composer, Node.js и Nginx, тем самым значительно уменьшает вероятность ошибок при развёртывании. Благодаря слоистости образов и кэшированию, повторная сборка занимает меньше времени, а использование docker-compose упрощает одновременный запуск нескольких компонент системы и управление внутренними сетями. В процессе разработки и эксплуатации контейнеризация обеспечила удобство и стабильность: любой разработчик или проверяющий может развернуть проект одной командой без дополнительных настроек среды. Это особенно важно при работе с Laravel, поскольку гарантируется корректная работа всех зависимостей и PHP-расширений, а также при использовании фронтенда на Vite, требующего определённой версии Node.js.
Для управления контейнерами и их состоянием использовалась среда Docker Desktop, предоставляющая графический интерфейс мониторинга, просмотра логов, работы с volumes и сетями. Это значительно облегчило тестирование и отладку, особенно на этапе интеграции баз данных и автоматического выполнения миграций. Выбор Docker оказался оптимальным решением для проекта, так как позволил добиться высокой степени автоматизации, ускорил развёртывание и обеспечил консистентность среды в процессе всей разработки.

Для развертывания фронтенд-части программной системы используется заранее подготовленный Dockerfile, помещённый в корневой каталог фронтенд-проекта. В процессе развертывания применяется среда Docker Desktop, обеспечивающая удобный интерфейс управления контейнерами, сетями и образами, а также автоматический запуск Docker Engine. Docker Desktop полностью исключает необходимость ручной настройки Docker-демона – после установки он запускается автоматически, что позволяет сразу переходить к сборке контейнеров.
В Dockerfile фронтенда в качестве базового образа используется Node.js. Далее происходит копирование файлов проекта инструкцией COPY . ., установка всех зависимостей через npm install, после чего проводится сборка приложения с помощью npm run build. Статические файлы, полученные после сборки, переносятся во второй этап Dockerfile, основанный на минимальном образе Nginx. Конфигурация веб-сервера подключается через файл nginx.conf, а финальные артефакты сборки размещаются в директории /usr/share/nginx/html. Старт сервера обеспечивается командой CMD ["nginx", "-g", "daemon off;"], которая активирует постоянную работу Nginx внутри контейнера.
Запуск фронтенда осуществляется через файл docker-compose.yml, включённый в отчёт. В нём описана служба, указывающая путь к Dockerfile проекта, а также проброс портов, например "5173:5173" или "8080:80" в случае продакшн-варианта. Docker Desktop автоматически обрабатывает конфигурацию docker-compose и запускает контейнеры. Чтобы развернуть фронтенд, достаточно выполнить команду docker-compose up -d, после чего Docker Desktop выполнит сборку образа, поднимет контейнер и отобразит его в пользовательском интерфейсе, что позволяет отслеживать состояние сервиса и логи выполнения.
DockerFile представлен ниже:

```
# Используем официальный образ Node.js
FROM node:20-alpine

ARG VITE_API_URL

ENV VITE_API_URL=$VITE_API_URL

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем package.json и package-lock.json
COPY package*.json ./

# Устанавливаем зависимости
RUN npm install

# Копируем весь проект
COPY . .

# Задаем аргумент для выбора окружения (по умолчанию production)

# Выполняем сборку в зависимости от окружения
# RUN npm run build

# Указываем команду для запуска
CMD npm run dev -- --host
```

В данном Dockerfile используется официальный облегчённый образ Node.js версии 20 на базе Alpine Linux. Alpine обеспечивает минимальный размер образа, а Node.js необходим для выполнения JavaScript-кода и сборки фронтенд-приложения. В качестве аргумента сборки задаётся переменная VITE_API_URL, которая позволяет динамически указывать адрес API, к которому будет обращаться фронтенд. Эта переменная затем устанавливается внутри контейнера через директиву ENV, что делает её доступной приложению во время сборки и выполнения, и Vite использует её для подстановки URL API через import.meta.env.VITE_API_URL.
Рабочая директория внутри контейнера устанавливается как /app, и все последующие команды выполняются относительно этого каталога. Сначала копируются файлы package.json и package-lock.json, необходимые для установки зависимостей проекта, после чего выполняется команда npm install, которая устанавливает все зависимости, указанные в package.json. Далее весь исходный код проекта копируется внутрь контейнера, что позволяет собрать и запустить приложение полностью внутри изолированного окружения.
В Dockerfile предусмотрено выполнение сборки в зависимости от окружения, хотя в данном варианте строка RUN npm run build закомментирована, что указывает на то, что контейнер нацелен на запуск в режиме разработки. Команда запуска задаётся через CMD npm run dev -- --host, которая активирует Vite-сервер в режиме разработки и позволяет обращаться к приложению извне контейнера. Таким образом, данный Dockerfile обеспечивает подготовку полностью изолированного фронтенд-окружения с установленными зависимостями и готовностью к разработке или тестированию. Далее будет представлен файл docker-compose.yml.

 ```
services:
  app-test:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        VITE_API_URL: http://77.220.212.158:9000
    ports:
      - "5173:5173"
```

Этот фрагмент docker-compose.yml описывает службу фронтенда и задаёт параметры её сборки и запуска. В данном случае создаётся сервис с именем app-test, который строится на основе Dockerfile, находящегося в текущей директории проекта (context: .). При сборке контейнера в него передаётся аргумент VITE_API_URL, содержащий адрес API бэкенда (http://77.220.212.158:9000), что позволяет фронтенд-приложению динамически подключаться к нужному серверу при запуске.
Для доступа к приложению снаружи контейнера проброшен порт 5173:5173, где первый номер – это порт на локальной машине, а второй – внутренний порт контейнера, на котором работает Vite-сервер. Благодаря этому фронтенд становится доступным в браузере по адресу http://localhost:5173 или по IP сервера, если контейнер развёрнут удалённо. Docker Compose автоматически собирает образ, используя Dockerfile и переданный аргумент, создаёт контейнер и подключает его к внутренней сети, обеспечивая возможность взаимодействия с другими сервисами, если они будут подключены к той же сети.
Таким образом, данный блок в compose-файле полностью автоматизирует сборку и запуск фронтенд-приложения, позволяя развернуть проект одной командой, без ручной настройки Node.js, npm или серверного окружения.

Для развёртывания серверной части используется собственный Dockerfile Laravel-проекта. Он формируется на основе официального PHP-образа, в который дополнительно устанавливаются необходимые расширения, такие как pdo_mysql, mbstring, bcmath и другие. После копирования исходных файлов Laravel (COPY . .) выполняется установка зависимостей через Composer командой composer install, а также назначение необходимых прав на каталоги storage и bootstrap/cache. Рабочая директория задаётся как /var/www.
Запуск backend-части организован через docker-compose.yml, содержащий два сервиса: MySQL и Laravel. Сервис MySQL создан на основе официального образа mysql:8, конфигурация передаётся через переменные окружения MYSQL_ROOT_PASSWORD, MYSQL_DATABASE, MYSQL_USER и MYSQL_PASSWORD. Для хранения данных используется volume db_data, позволяющий не терять данные при перезапуске контейнера. Порт "3307:3306" пробрасывается наружу, обеспечивая возможность прямого подключения к базе данных через сторонние инструменты, включая MySQL Workbench. Docker Desktop наглядно отображает состояние базы данных и объём занятого пространства внутри volume'ов.
Laravel-сервис собирается из Dockerfile backend-части. В docker-compose.yml ему передаются параметры подключения к базе данных: DB_HOST=mysqltest1, DB_PORT=3306, DB_DATABASE=admin_panel, DB_USERNAME=root, DB_PASSWORD=NewPass123!. Перед запуском Laravel выполняется проверка готовности базы данных через цикл:

```
until mysqladmin ping -h mysqltest1 -u root -proot --silent; do
  echo 'Waiting for MySQL to be ready...';
  sleep 2;
done;
```

После того как база становится доступной, контейнер автоматически выполняет команду миграции:

```
php artisan migrate –force
```

и затем начинает заполнение базы начальными данными:

```
php artisan db:seed –force
```

После инициализации Laravel запускает встроенный сервер командой:

```
php artisan serve --host=0.0.0.0 --port=9000
```

что делает API доступным по адресу http://localhost:9000. Все процессы развертывания можно наблюдать в Docker Desktop – там отображаются запущенные контейнеры, их ресурсы, логи, конфигурация и сетевые подключения.
Полное развертывание backend-части выполняется одной командой:

```
docker-compose up -d
```

Docker Desktop автоматически создаёт и запускает контейнеры: сначала MySQL, затем Laravel, после чего система полностью готова к работе. DockerFile представлен ниже.

```
FROM php:8.3-fpm
```

# Установка зависимостей

```
RUN apt-get update && apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip \
    default-mysql-client  # Добавляем mysql-client для mysqladmin

# Установка PHP-расширений
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Установка Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Установка рабочей директории
WORKDIR /var/www

# Копирование файлов проекта
COPY . /var/www

# Установка зависимостей Composer
RUN composer install --optimize-autoloader --no-dev

# Права на файлы
RUN chown -R www-data:www-data /var/www \
    && chmod -R 755 /var/www/storage

# Открытие порта
EXPOSE 9000

RUN php artisan cache:clear

CMD ["php-fpm"]
```

docker-compose.yml предствален ниже:

```
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:ee3VcwnWG5PwrBFXSIpVUaMluHQeJyCUKVJcaK6oLuY=
APP_DEBUG=true
APP_URL=http://localhost

APP_LOCALE=en
APP_FALLBACK_LOCALE=en
APP_FAKER_LOCALE=en_US

APP_MAINTENANCE_DRIVER=file
# APP_MAINTENANCE_STORE=database

# PHP_CLI_SERVER_WORKERS=4

BCRYPT_ROUNDS=12

LOG_CHANNEL=stack
LOG_STACK=single
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=admin_panel
DB_USERNAME=root
DB_PASSWORD=NewPass123!

SESSION_DRIVER=database
SESSION_LIFETIME=120
SESSION_ENCRYPT=false
SESSION_PATH=/
SESSION_DOMAIN=null

BROADCAST_CONNECTION=log
FILESYSTEM_DISK=local
QUEUE_CONNECTION=database

CACHE_STORE=database
# CACHE_PREFIX=

MEMCACHED_HOST=127.0.0.1

REDIS_CLIENT=phpredis
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=log
MAIL_SCHEME=null
MAIL_HOST=127.0.0.1
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

VITE_APP_NAME="${APP_NAME}"
```


### Манифесты для развертывания k8s кластера

## Лицензия

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]


## Контакты

Автор: email

+375291965762 Елизавета
