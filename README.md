# Программное средство для администрирования распределенных информационных киосков организации

Описание проекта: Проект представляет собой программное средство для администрирования распределённых информационных киосков организации. Система предназначена для централизованного управления сетью киосков, которые предоставляют пользователям доступ к различным информационным и интерактивным сервисам. Основной задачей проекта является упрощение процесса администрирования, мониторинга и обновления контента на всех устройствах, что обеспечивает их стабильную работу и актуальность предоставляемой информации.

Цели проекта: Главная цель проекта — повышение эффективности управления распределёнными информационными киосками. Система позволит сократить время и ресурсы, затрачиваемые на обслуживание оборудования, упростить процесс обновления программного обеспечения и контента, а также обеспечить высокий уровень контроля за работой киосков в режиме реального времени.

Основные возможности: Программное средство предоставляет централизованное управление сетью киосков, позволяя администраторам контролировать их состояние, обновлять программное обеспечение и контент, управлять пользователями и их правами доступа. Система формирует аналитические отчёты и статистику работы киосков, что способствует оптимизации их использования. Кроме того, она обеспечивает автоматическую отправку уведомлений о неисправностях и сбоях, что позволяет быстро реагировать на проблемы. Решение отличается высокой надёжностью, безопасностью данных и возможностью масштабирования при увеличении количества устройств.

**Front:** [GitHub репозиторий](https://github.com/lizgorovaya/ADMFront)  
**Back:** [GitHub репозиторий](https://github.com/lizgorovaya/ADMBack)


## Содержание

1. [Архитектура](#архитектура)  
   i. [C4-модель](#c4-модель)  
   ii. [Схема данных](#схема-данных)  

2. [Функциональные возможности](#функциональные-возможности)  
   i. [Диаграмма вариантов использования](#диаграмма-вариантов-использования)  
   ii. [User-flow диаграммы](#user-flow-диаграммы)  

3. [Детали реализации](#детали-реализации)  
   i. [UML-диаграммы](#uml-диаграммы)  
   ii. [Спецификация API](#спецификация-api)  
   iii. [Безопасность](#безопасность)  
   iv. [Оценка качества кода](#оценка-качества-кода)  

4. [Тестирование](#тестирование)  
   i. [Unit-тесты](#unit-тесты)  
   ii. [Интеграционные тесты](#интеграционные-тесты)  

5. [Установка и запуск](#установка-и-запуск)  
   i. [Манифесты для сборки docker образов](#манифесты-для-сборки-docker-образов)  
   ii. [Манифесты для развертывания k8s кластера](#манифесты-для-развертывания-k8s-кластера)  

6. [Лицензия](#лицензия)  
7. [Контакты](#контакты)




## Архитектура

### C4-модель


Модель C4 важна при построении архитектуры программных систем, так как она позволяет наглядно и поэтапно описывать структуру проекта на разных уровнях абстракции. С её помощью можно показать, как система взаимодействует с внешними пользователями и другими системами, из каких контейнеров (приложений, сервисов, баз данных) она состоит, как устроены её внутренние компоненты и каким образом реализован код. На рисунке 1 представлена модель контейнерного уровня С4.

<img width="975" height="631" alt="image" src="https://github.com/user-attachments/assets/6cefd2be-f334-46b0-89e5-44ad8f36fdf5" />

Диаграмма описывает систему взаимодействия пользователей с программным средством администрирования инфокиосков, предназначенную для централизованного управления контентом, пользователями и аналитикой. Администратор Брестэнерго управляет системой и пользователями, контролирует работу контент-менеджеров и аналитиков, а также следит за состоянием инфокиосков через веб-сервис администрирования. Контент-менеджер редактирует и обновляет материалы, которые отображаются на инфокиосках, загружает новые данные и корректирует существующий контент. Аналитик просматривает отчёты и статистику использования инфокиосков, получая информацию о посещаемости, активности пользователей и эффективности контента через программное средство.    
Программное средство администрирования является центральным элементом системы, обеспечивая взаимодействие всех пользователей и получая контент от внешних систем, представленных тремя экземплярами инфокиосков. Пользователи работают с веб-сервисом, который, в свою очередь, интегрирован с инфокиосками для актуализации контента, а администратор обеспечивает корректную работу системы и управление ролями. Таким образом, система обеспечивает централизованное управление контентом, контроль доступа и ролей пользователей, получение и отображение аналитических данных и взаимодействие с внешними инфокиосками для поддержания актуальности информации.
Далее представлена компонентный уровень модели С4 для детального представления программного обеспечения внутри одного контейнера. Она показывает, как система организована из отдельных компонентов, какие у них обязанности, как они взаимодействуют друг с другом и с внешними системами. На рисунке 2 представлена модель компонентного уровня модели С4.

<img width="974" height="494" alt="image" src="https://github.com/user-attachments/assets/f055a10b-52f4-4876-843f-028092d4db88" />

В системе выделяется три типа пользователей. Администратор управляет системой и пользователями, назначает роли, контролирует корректность работы контент-менеджеров и аналитиков, а также мониторит работу инфокиосков. Контент-менеджер отвечает за подготовку и публикацию материалов: он редактирует текст, изображения и другие элементы контента, который затем отображается на инфокиосках. Аналитик получает доступ к отчётам и статистике, формируемой системой, что позволяет оценивать эффективность публикаций и активность пользователей. Все пользователи взаимодействуют с системой через веб-приложение, которое служит интерфейсом для выполнения всех задач: управления пользователями, публикации контента и просмотра аналитики.
Веб-приложение представляет собой фронтенд, построенный как клиентское веб-приложение, которое делает запросы к API-сервису. Оно обеспечивает удобный интерфейс и визуализацию данных для всех типов пользователей, управляет навигацией, формами редактирования и представлением отчётов.
API-сервис является центральным компонентом backend. Он обрабатывает запросы веб-приложения, управляет пользователями и ролями, хранит и обновляет контент, собирает и обрабатывает журналы посещений от инфокиосков. Кроме того, API-сервис реализует бизнес-логику и маршрутизацию данных между компонентами системы, обеспечивая целостность и согласованность информации.
База данных MySQL хранит всю основную информацию: сведения о пользователях, их ролях, опубликованном контенте и журналы посещений инфокиосков. Она служит основным источником данных для API-сервиса и модуля аналитики.
Инфокиоски подключаются к системе через API-сервис. Они получают актуальный контент для отображения и передают обратно журналы посещений и другую статистическую информацию. Это позволяет системе поддерживать контент в актуальном состоянии и собирать данные для анализа.
Модуль аналитики, встроенный в backend, обрабатывает журналы посещений, анализирует активность пользователей и эффективность контента, а затем формирует отчёты, доступные аналитикам через веб-приложение. Модуль позволяет оценивать работу инфокиосков, выявлять популярный контент и принимать управленческие решения.
Таким образом, система реализует полный цикл администрирования и анализа: пользователи через веб-приложение управляют контентом и ролями, API-сервис обеспечивает обработку данных и взаимодействие с базой, инфокиоски получают контент и передают статистику, а модуль аналитики формирует отчёты для оценки эффективности работы системы.

### Схема данных

<img width="974" height="480" alt="image" src="https://github.com/user-attachments/assets/0a2f34a2-251c-4c45-b1be-1e8f36a1da4f" />


Проектируемая база данных kiosk_admin соответствует требованиям третьей нормальной формы (3НФ), так как все таблицы содержат атрибуты, функционально зависящие только от своих первичных ключей, и не имеют транзитивных зависимостей между неключевыми полями. 
Таблица users. Таблица хранит информацию о пользователях системы. Каждый атрибут (username, password_hash, role, created_at) однозначно зависит от первичного ключа id. Между неключевыми атрибутами функциональных зависимостей нет – роль пользователя не зависит от его имени или даты создания записи. Следовательно, таблица users находится в 3НФ.
Таблица kiosks. Таблица содержит сведения о киосках, подключённых к системе. Все поля (name, location, ip_address, status, last_sync) зависят исключительно от ключа id. Поле status не зависит ни от имени, ни от IP-адреса, что исключает транзитивные зависимости. Таким образом, таблица kiosks удовлетворяет требованиям 3НФ.
Таблица content_types Таблица описывает типы контента (текст, изображение, видео). Атрибут name функционально зависит только от id, и так как других неключевых атрибутов нет, таблица полностью нормализована. content_types находится в 3НФ.
Таблица contents. Таблица хранит контент, размещаемый на киосках. Атрибуты (title, type_id, data_url, created_by, created_at, updated_at) полностью зависят от первичного ключа id. Поля type_id и created_by являются внешними ключами, которые обеспечивают связь с таблицами content_types и users, исключая дублирование данных. Зависимостей между неключевыми полями нет. Таблица находится в 3НФ.
Таблица deployments описывает размещение контента на киосках. Каждый атрибут (kiosk_id, content_id, deployed_at, status) зависит только от идентификатора развертывания id. Внешние ключи kiosk_id и content_id корректно связывают таблицу с киосками и контентом, обеспечивая целостность данных. Никаких транзитивных зависимостей между полями нет, следовательно, таблица соответствует 3НФ.
Таблица logs предназначена для хранения журналов событий, связанных с киосками. Поля (kiosk_id, level, message, created_at) функционально зависят от первичного ключа id. Поле kiosk_id является внешним ключом, связывающим запись лога с конкретным киоском. В таблице отсутствуют зависимости между неключевыми атрибутами, поэтому она также находится в 3НФ.


## Функциональные возможности

### Диаграмма вариантов использования

### User-flow диаграммы

Первый разработанный user-flow для роли – системный администратор.
Цель роли системный администратор обеспечивает безопасное и стабильное функционирование всей системы администрирования киосков. Он управляет правами доступа пользователей, контролирует действия сотрудников и следит за соблюдением политик безопасности. Роль позволяет централизованно управлять учетными записями, отслеживать все действия через журналы аудита, настраивать параметры безопасности, выполнять резервное копирование и восстановление данных. Основная цель – гарантировать, что доступ к системе имеют только уполномоченные пользователи и что вся информация надёжно защищена. Ниже описан основной путь следования системного администратора.
1 Администратор открывает страницу входа в систему и видит форму для авторизации. Он вводит логин и пароль, чтобы система могла идентифицировать его и проверить, что у него есть права администратора. Этот шаг необходим для защиты системы от несанкционированного доступа.
2 После ввода учетных данных система предлагает пройти двухфакторную аутентификацию или авторизацию через корпоративный SSO. Пользователь подтверждает свою личность с помощью кода из приложения или через корпоративный аккаунт. Это повышает безопасность и предотвращает доступ злоумышленников.
3 После успешной авторизации администратор попадает на главную панель. Здесь отображается обзор состояния системы: уведомления о действиях пользователей, последние изменения, ошибки, предупреждения, а также быстрые ссылки на основные модули.
4 Администратор выбирает модуль управления пользователями. Здесь он может создавать новых пользователей, задавать роли и права, редактировать информацию о существующих пользователях или удалять учетные записи, если они больше не нужны. Система обеспечивает контроль, чтобы изменения не повлияли на безопасность.
5 Если выбранный пользователь требует прав суперпользователя, администратор переходит в модуль настройки политик безопасности. Здесь он устанавливает ограничения доступа, проверяет полномочия и сохраняет изменения. После этого возвращается на главную панель.
6 Администратор может открыть журналы аудита, чтобы просмотреть историю действий пользователей: входы в систему, изменения данных, ошибки и подозрительные действия. При необходимости журналы можно экспортировать для анализа или отчёта.
7 Далее администратор может настроить параметры безопасности системы, включая политику паролей, ограничения доступа, двухфакторную аутентификацию и другие настройки, которые обеспечивают защиту данных.
8 При необходимости выполняется резервное копирование данных или восстановление из предыдущей копии, чтобы предотвратить потерю информации в случае сбоев или ошибок.
9 После завершения всех операций администратор выходит из системы, закрывая сеанс работы и обеспечивая безопасность системы.
Диаграмма User-flow для системного администратора представлена на рисунке 1.

<img width="974" height="767" alt="image" src="https://github.com/user-attachments/assets/fb2fd64c-c027-4bec-9075-970eae385430" />


Следующая роль, которая представлена в системе, администратор киосков. 
Цель роли: Администратор киосков отвечает за управление жизненным циклом всех устройств организации. Он добавляет новые киоски в систему, настраивает их параметры, редактирует существующие и удаляет ненужные устройства. Также он отслеживает состояние устройств, просматривает логи работы и формирует отчёты для анализа эффективности работы киосков. Основная цель роли – обеспечить корректную работу всех киосков, своевременное обновление программного обеспечения и контроль состояния устройств, чтобы пользователи и клиенты получали качественный и актуальный контент. Далее будет описан user flow для администратора киоска.
1 Администратор киосков открывает страницу входа и вводит логин и пароль для доступа к панели управления киосками.
2 После авторизации он попадает на обзорную панель, где отображаются все киоски организации с текущим состоянием: активные, оффлайн, с ошибками, с доступным или устаревшим контентом.
3 Пользователь может добавить новый киоск. Для этого открывается форма, где нужно указать название, местоположение, сетевые настройки, тип контента и другие параметры. После сохранения новый киоск появляется в общем списке и готов к работе.
4 Для существующих киосков администратор открывает форму редактирования и изменяет необходимые параметры: обновляет программное обеспечение, корректирует настройки отображения контента и сохраняет изменения.
5 Если киоск больше не нужен, администратор выбирает его и удаляет. Система запрашивает подтверждение, чтобы предотвратить случайное удаление, после чего киоск удаляется из системы.
6 Пользователь может просматривать текущее состояние киосков, проверять активность контента, сетевые подключения и логи работы устройств для диагностики проблем.
7 Администратор формирует отчёты по выбранным киоскам, включая данные о состоянии, ошибках, обновлениях и активности контента. Отчёты можно скачать для анализа и передачи руководству.
8 После завершения всех действий администратор выходит из системы, завершая сеанс работы.
Ниже представлена диаграмма user flow для системного администратора на рисунке 2.


<img width="974" height="339" alt="image" src="https://github.com/user-attachments/assets/a1a9a18c-c918-423f-9160-15042337f7b8" />


Следующая роль, которая представлена в системе, редактор контента. Цель роли: Редактор контента отвечает за подготовку, организацию и публикацию материалов на киосках. Он загружает новые файлы, редактирует метаданные, создаёт плейлисты и планирует публикации на определённых устройствах. Эта роль обеспечивает, что контент отображается корректно, вовремя и в нужных местах. Основная цель роли – гарантировать, что на киосках всегда актуальная и правильно организованная информация для конечных пользователей, а процесс публикации автоматизирован и управляем.
1 Редактор контента входит в систему, вводя свои учетные данные для доступа к панели управления контентом.
2 После авторизации он попадает на главную панель, где отображается текущий контент, расписание публикаций, доступные плейлисты и уведомления о новых материалах.
3 Пользователь открывает библиотеку контента и просматривает загруженные материалы. Контент отсортирован по категориям и типам, что позволяет быстро находить нужные материалы.
4 Редактор загружает новый контент: выбирает файлы, добавляет описание, категории, ключевые метаданные. После загрузки материалы становятся доступными для использования в плейлистах и публикации на киосках.
5 Далее пользователь создаёт плейлист, добавляя выбранные материалы. Плейлист сохраняется и становится доступным для планирования публикаций.
6 Для публикации контента редактор открывает планировщик, выбирает киоски, задаёт дату и время публикации и подтверждает отправку. Система автоматически распределяет контент на выбранные устройства.
7 После публикации редактор может выполнить предпросмотр, чтобы убедиться, что контент корректно отображается на киосках, все метаданные верны, а видео и изображения воспроизводятся правильно.
8 После завершения всех действий редактор выходит из системы, закрывая сеанс работы.
Далее представлена диаграмма user-flow на рисунке 3.

<img width="771" height="455" alt="image" src="https://github.com/user-attachments/assets/eb916750-24a7-4cdc-bd73-24ee89e1f3b2" />

Следующая роль, которая представлена в системе, техник. Цель роли:
Техник отвечает за обслуживание и диагностику киосков на местах или удалённо. Он проводит проверку состояния устройств, выявляет неисправности, выполняет удалённое управление, перезагрузку или собирает логи для анализа. Также техник планирует обновления программного обеспечения и фиксирует результаты своих действий в отчётах. Основная цель роли – обеспечить бесперебойную работу киосков и быстрое устранение технических проблем, минимизируя время простоя устройств.
Далее представлено описание user-flow. 
1 Техник входит в систему и попадает на панель с текущими заданиями и тикетами на обслуживание киосков.
2 Пользователь просматривает список заданий и выбирает киоск, который необходимо обслужить.
3 Техник запускает диагностику выбранного киоска с помощью удаленного мониторинга: проверяет состояние устройства, работоспособность контента, подключение к сети и ошибки системы.
4 В зависимости от результата диагностики:
Если киоск неисправен, техник выполняет необходимые действия: удалённое управление, перезагрузку устройства, сбор логов для последующего анализа.
Если киоск исправен, техник планирует обновление программного обеспечения для поддержания актуальности и безопасности.
5 После выполнения всех действий техник создаёт отчёт, в котором фиксирует состояние киоска, выполненные операции, выявленные ошибки и рекомендации.
6 Техник закрывает тикет и возвращается к списку заданий для выполнения следующих операций.
7 После выполнения всех задач техник выходит из системы, завершив рабочий сеанс.
Далее представлена диаграмма user-flow на рисунке 4.


<img width="479" height="654" alt="image" src="https://github.com/user-attachments/assets/780d4d30-3662-4746-9ca2-071a90dc016f" />


Следующая роль, которая представлена в системе, оператор поддержки.
Цель роли: Оператор поддержки отвечает за обработку инцидентов и обращений, связанных с работой киосков. Он просматривает очередь тикетов, выбирает конкретные инциденты для обработки, решает их самостоятельно или эскалирует к технику. Также оператор фиксирует результаты работы и формирует отчёты. Основная цель роли – поддерживать бесперебойную работу киосков, оперативно решать проблемы пользователей и обеспечивать корректную работу системы поддержки.
Далее представлено описание user-flow. 
1 Оператор поддержки входит в систему и попадает на панель с очередью инцидентов и тикетов.
2 Пользователь просматривает список инцидентов, сортируя их по приоритету, дате создания или типу проблемы.
3 Оператор выбирает конкретный инцидент для обработки.
4 В зависимости от характера проблемы оператор решает, нужна ли эскалация:
Если требуется вмешательство техника, он передаёт задачу и фиксирует информацию о передаче.
Если эскалация не требуется, выполняет автоматическое решение или перезапуск системы для устранения проблемы.
5 После решения инцидента оператор закрывает тикет и фиксирует результат обработки.
6 При необходимости формирует отчёты о работе с инцидентами, включая количество закрытых тикетов, причины обращений и результаты обработки.
7 Возвращается к очереди инцидентов для обработки новых задач.
8 После завершения всех действий оператор выходит из системы.
Далее представлена диаграмма user-flow на рисунке 5.

<img width="730" height="881" alt="image" src="https://github.com/user-attachments/assets/4a683b26-8ad6-424c-a3ea-d7a04dc05935" />


Следующая роль, которая представлена в системе, аналитик. Цель роли:
Аналитик отвечает за сбор, обработку и анализ данных о работе киосков и контента. Он формирует отчёты, строит визуализации и графики, чтобы оценить эффективность работы устройств, публикаций и активности пользователей. Также он планирует автоматическую генерацию отчётов для регулярного контроля. Основная цель роли – предоставить руководству и ответственным сотрудникам точную информацию для принятия решений, улучшения работы системы и оптимизации процессов управления контентом и устройствами.
1 Пользователь входит в систему и получает доступ к панели аналитики.
2 На панели аналитики отображается информация о состоянии всех киосков, активности контента, публикациях и ошибках.
3 Пользователь выбирает тип отчёта для анализа: отчёт по контенту, по состоянию киосков или по активности пользователей.
4 Отфильтровывает данные по критериям: временной период, конкретные киоски, категории контента и другие параметры.
5 Генерирует отчёт и просматривает визуализации, графики и диаграммы для анализа эффективности работы киосков.
6 При необходимости экспортирует отчёт в PDF или CSV, чтобы передать его руководству или использовать в презентации.
7 Планирует автоматическое формирование отчётов на регулярной основе, чтобы получать актуальные данные без ручного вмешательства.
8 После завершения всех операций пользователь выходит из системы, закрывая сеанс работы.
Далее представлена диаграмма user-flow на рисунке 6.

<img width="547" height="725" alt="image" src="https://github.com/user-attachments/assets/202abb6b-b6b9-466a-a8ff-9e8745082c60" />



## Детали реализации

# Распространённые ошибки при разработке на Laravel

Разработка на Laravel даёт множество встроенных инструментов для ускорения работы. Однако именно из-за этого программисты часто допускают ошибки, которые приводят к некачественному коду. Наиболее распространённые из них связаны с:  

- Перегрузкой контроллеров  
- Дублированием логики  
- Неправильной работой с базой данных  
- Отсутствием обработки ошибок  
- Нарушением архитектурных принципов  

Часто вся логика — от валидации входных данных и бизнес-правил до взаимодействия с базой и отправки уведомлений — пишется в одном методе. Такой код трудно поддерживать и тестировать.  

```php
public function store(Request $request)
{
    if (!$request->has('email')) {
        return response()->json(['error' => 'Email is required'], 400);
    }

    $user = new User();
    $user->name = $request->input('name');
    $user->email = $request->input('email');
    $user->save();

    Mail::to($user->email)->send(new WelcomeMail($user));

    return response()->json(['message' => 'User created']);
}

```

Исправление заключается в разделении ответственности. Валидацию стоит вынести в отдельный FormRequest, бизнес-логику – в сервисный слой, а отправку писем – в очередь.

```php
// Хороший код
public function store(CreateUserRequest $request, UserService $service)
{
    $user = $service->createUser($request->validated());
    return response()->json(['message' => 'User created']);
}

```

Не менее частой ошибкой является дублирование кода. В приложениях для администрирования киосков, например, активация и деактивация может повторяться в разных контроллерах.

```php
// Плохой код
$user->status = 'inactive';
$user->save();

$kiosk->status = 'inactive';
$kiosk->save();

```

Чтобы избежать повторов, стоит вынести логику в общий метод.

```php
// Хороший код
public function deactivate(Model $entity)
{
    $entity->status = 'inactive';
    $entity->save();
}

```

Серьёзной проблемой является неэффективная работа с базой данных. Одной из типичных ошибок считается загрузка всех записей через Model::all(), даже если нужно обработать миллионы строк.

```php
// Плохой код
$logs = LogEntry::all();
foreach ($logs as $log) {
    // обработка
}
```

Это приводит к утечке памяти. Более эффективный подход – использовать chunk:

```php
// Хороший код
LogEntry::chunk(500, function ($logs) {
    foreach ($logs as $log) {
        // обработка
    }
});

```

Другая проблема связана с так называемой ошибкой N+1 запросов. Она возникает, когда для каждой записи делается отдельный запрос к связанным данным.

```php
// Плохой код
$users = User::all();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Laravel при этом выполняет десятки дополнительных запросов. Исправление заключается в использовании жадной загрузки:

```php
// Хороший код
$users = User::with('profile')->get();
foreach ($users as $user) {
    echo $user->profile->address;
}
```

Проблемой можно назвать и отсутствие обработки ошибок. Например, попытка получить пользователя по ID без проверки может привести к фатальной ошибке:

```php
// Плохой код
$user = User::find($id);
return $user->email;
```

Гораздо лучше обрабатывать ситуации, когда объект не найден:

```php
// Хороший код
$user = User::find($id);
if (!$user) {
    return response()->json(['error' => 'User not found'], 404);
}
return $user->email;
```

Часто встречается и плохой нейминг функций и переменных. Код с названиями вроде doIt($a, $b) непонятен даже автору спустя время.

```php
// Плохой код
function doIt($a, $b) {
    return $a + $b;
}
```

Хорошее название делает код самодокументируемым:

```php
// Хороший код
function calculateInvoiceTotal($subtotal, $tax) {
    return $subtotal + $tax;
}
```

Ещё одна распространённая ошибка – использование временных переменных, которые не добавляют смысла.

```php
// Плохой код
$tmp = $request->input('location');
$kiosk->location = $tmp;
```

Запись можно упростить:

```php
// Хороший код
$kiosk->location = $request->input('location');

Отдельно стоит выделить захардкоденные значения в коде. Например:

```php
// Плохой код
if ($user->role === 'admin') {
    // особая логика
}
```

Лучше использовать константы или конфиги:

```php
// Хороший код
if ($user->role === User::ROLE_ADMIN) {
    // особая логика
}
```

# Распространённые проблемы и ошибки при разработке на Angular

Во фронтенд-разработке на Angular можно встретить похожие по сути проблемы, что и в Laravel, но проявляются они по-своему. Основная из них связана с перегруженными компонентами.  

Разработчики часто помещают и бизнес-логику, и работу с API, и управление состоянием прямо в компонент. Такой подход затрудняет сопровождение и тестирование.  

---

```typescript
/Плохой пример
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users: any[] = [];
  constructor(private http: HttpClient) {
    this.http.get<any[]>('/api/users').subscribe(data => {
      this.users = data.filter(u => u.active);
    });
  }
}
```

Лучшим решением является вынесение логики работы с данными в отдельный сервис, а компонент должен только подписываться на поток данных.

```typescript
// Хороший код (разделение обязанностей)
@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}
  getActiveUsers() {
    return this.http.get<User[]>('/api/users')
      .pipe(map(users => users.filter(u => u.active)));
  }
}
```
```typescript
@Component({
  selector: 'app-users',
  templateUrl: './users.component.html'
})
export class UsersComponent {
  users$ = this.userService.getActiveUsers();
  constructor(private userService: UserService) {}
}
```

Другая распространённая ошибка связана с утечками памяти из-за отсутствия отписки от подписок. Когда в компоненте используется subscribe, но отписка в ngOnDestroy не реализована, память продолжает удерживать подписки даже после удаления компонента.

```typescript
// Плохой код (подписка без отписки)
ngOnInit() {
  this.http.get('/api/data').subscribe(result => {
    this.data = result;
  });
}
```

Исправлением является либо явная отписка с помощью Subject и takeUntil, либо использование async pipe, который сам управляет подпиской.

```typescript
// Хороший код (async pipe)
data$ = this.http.get('/api/data');
<div *ngIf="data$ | async as data">
  {{ data }}
</div>
```

Часто встречается и проблема слишком сложной логики прямо в шаблонах. Например:

```typescript
<!-- Плохой код -->
<div>{{ users.filter(u => u.active).map(u => u.name).join(', ') }}</div>
```

Каждый цикл изменения состояния Angular будет заново выполнять фильтрацию и объединение строк, что негативно сказывается на производительности. Логичнее вынести подготовку данных в компонент:

```typescript
// Хороший код
activeUserNames = '';
ngOnInit() {
  this.userService.getActiveUsers().subscribe(users => {
    this.activeUserNames = users.map(u => u.name).join(', ');
  });
}

<div>{{ activeUserNames }}</div>

```

Неудачные имена переменных и методов также характерны для Angular. Код с переменными вроде d, arr, tmp становится нечитаемым:

```typescript
// Плохой код
let d = this.http.get('/api/kiosks');

```

Понятные названия делают код самодокументируемым:

```typescript
let kiosks$ = this.http.get<Kiosk[]>('/api/kiosks');
```

В Angular иногда встречается и чрезмерное использование any, что убивает преимущества TypeScript.

```typescript
// Плохой код
users: any[] = [];
```

Гораздо правильнее использовать строгую типизацию:

```typescript
// Хороший код
users: User[] = [];
```

Оптимизационные ошибки также играют важную роль. Например, использование *ngFor без ключа trackBy при больших списках приводит к тому, что Angular каждый раз пересоздаёт все элементы при малейшем изменении.

```typescript
<!-- Плохой код -->
<li *ngFor="let user of users">{{ user.name }}</li>
```

Гораздо лучше использовать trackBy, чтобы Angular понимал, какие элементы изменились, а какие остались прежними.

```typescript
<!-- Хороший код -->
<li *ngFor="let user of users; trackBy: trackById">{{ user.name }}</li>

trackById(index: number, item: User) {
  return item.id;
}
```

Неоптимальная работа с состоянием приложения также относится к типичным проблемам. Хранение сложных состояний прямо в компонентах затрудняет развитие кода. Лучшим решением является использование централизованного управления состоянием (NgRx или аналогичных решений).










### UML-диаграммы

### Спецификация API

### Безопасность

### Оценка качества кода

## Тестирование

### Unit-тесты

### Интеграционные тесты

## Установка и запуск

### Манифесты для сборки docker образов

### Манифесты для развертывания k8s кластера

## Лицензия

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]


## Контакты

Автор: email

+375291965762 Елизавета
